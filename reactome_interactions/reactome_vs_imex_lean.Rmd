---
title: Reactome dataset generation
date: 2016-04-13
author: Pablo Porras
---
```{r set-options, echo=FALSE}
options(width = 80)
```
Generation of the Reactome dataset: Technical report
========================================================

### Synopsis

The goal of this analysis is to use Reactome to try to find potentially non-curated protein interactions for which there is experimental evidence. I define a set of associated pairs as found in Reactome. Those proteins that are found to be present in the same reaction are combined according to their role.  

### Part 1: Loading Reactome data

The files used for this analysis were supplied by  at Reactome around end of June, 2015. I cannot use the interactions as exported by Reactome since they do not give a PMID for each inferred interacting pair and are then not usable. As a pre-load operation, I clean up the UniProtKB accessions given by Reactome to avoid using isoform identifiers. 

```{r eval=T,message=FALSE,warning=FALSE}
library(data.table)
library()
homo_sapiens_interactions = fread("./source_files/homo_sapiens_interactions.txt", colClasses = "character",sep = "\t", quote = "")
x = readLines("./source_files/homo_sapiens_interactions.txt")
xx = as.data.table(tstrsplit(x, fixed = T, split = "\t"))
colnames(xx) = unlist(xx[1,])
```

### Part 2: Select only human proteins

I need to query uniprot via a script as defined on their webpage (see [here](http://www.uniprot.org/help/programmatic_access#batch_retrieval_of_entries)), in order to get the taxIDs of the different organisms represented in the dataset. I will restrict the search to human interactions, so it is required to limit the search to those. 

```{r eval=FALSE}
system("perl ./scripts/up_batch_retr.pl ./processed_files/rr.upacs.txt > ./processed_files/rr.up_taxid.txt")     # This takes a LONG time, do not run unless 100% needed. 
```

The previous script takes a long time and cannot actually deal with isoforms, so I manually perform the query on the UniProtKB website using the retrieve/ID mapping tool. This allows for isoform mapping, but I also need to clean the results up so each UniProtKB accession is listed in a single line. 

```{r eval=FALSE}
system("perl ./scripts/multiplier.pl ./processed_files/rr.up_taxid_man.txt ./processed_files/rr.up_taxid_clean.txt")
```
```{r }
rr_up_taxid <- read.delim("./processed_files/rr.up_taxid_clean.txt", header = T, sep = "\t", colClasses = "character")
```

And I select human proteins only, which I use to select only those reactions involving human proteins from the original list. 

```{r eval=TRUE}
rr_up_human <- data.frame(rr_up_taxid[rr_up_taxid$Organism.ID == 9606,1])
colnames(rr_up_human) <- c("upac")

rr_prots_human <- unique(merge(rr_up_human, rr_prots, by = "upac", all.x=T, all.y=F))

rr_reacts_human <- unique(data.frame(rr_prots_human$rr_id))
colnames(rr_reacts_human) <- "rr_id"

rr_pmids_human <- unique(merge(rr_reacts_human, rr_pmids, by="rr_id", all=F))

react_pmids_human <- unique(subset(rr_pmids_human, !is.na(rr_pmids_human$pmid), select = "pmid"))
react_pmids_human$reactome <- "yes"
```

### Part 3: Generate Reactome association pairs

First I classify the human proteins in reactome using their types, in order to construct pairs to compare to intact interactions. I consider only the role types 'INPUT', 'OUTPUT' and 'CATALYST'. 


```{r eval=TRUE}
rr_p_h_input <- data.frame(rr_prots_human[rr_prots_human$type == "input",c(1,3)])
rr_p_h_output <- data.frame(rr_prots_human[rr_prots_human$type == "output",c(1,3)])
rr_p_h_catalyst <- data.frame(rr_prots_human[rr_prots_human$type == "catalystActivity",c(1,3)])
```

I generate the pairs of potential interactions, following these rules:

  *in-out pairs: proteins in a pair are annotated as 'INPUT' and 'OUTPUT' of a reaction, respectively.   
  *in-cat pairs: proteins annotated as 'INPUT' and 'CATALYST' in a reaction.  
  *out-cat pairs: proteins annotated as 'OUTPUT' and 'CATALYST' in a reaction.  

```{r eval=TRUE}
rr_pair_inout <- unique(merge(rr_p_h_input, rr_p_h_output, by="rr_id", all=F))
rr_pair_incat <- unique(merge(rr_p_h_input, rr_p_h_catalyst, by="rr_id", all=F))
rr_pair_outcat <- unique(merge(rr_p_h_output, rr_p_h_catalyst, by="rr_id", all=F))

rr_pairs_1 <- unique(rbind(rr_pair_inout, rr_pair_incat))
rr_pairs <- unique(rbind(rr_pairs_1, rr_pair_outcat))
```

I finally add the PMID information to each pair of associations and I check if there are reactions for which no PMID is available. 

```{r }
rr_pairs_pmid_all <- unique(merge(rr_pairs, rr_pmids_human, by="rr_id",all=F))
```

### Part 4: Final formatting steps for generation of the Reactome dataset

I generate a unique pair identifier per line and save the Reactome pairs associated with the PMIDs as a text file for further comparison with other datasets.

```{r message=FALSE,warning=FALSE}
library(dplyr)

rr_pairs_pmid_all$pair_id <- apply(rr_pairs_pmid_all[,2:3], 1,function(i){
  paste(sort(i),collapse = "_")
})
reactome_pairs_pmid <- unique(select(rr_pairs_pmid_all, pair_id, pmid))
reactome_pairs_pmid$reactome <- 1
write.table(reactome_pairs_pmid,"./results/pairs_pmid_reactome.txt",col.names=T,row.names=F,quote=F,sep="\t")
system("gzip ./results/pairs_pmid_reactome.txt")
```

After collapsing redundant pairs, I end up with a list of `r nrow(reactome_pairs_pmid)` unique protein pair-publication associations extracted from Reactome in human. 