---
title: "Comparison of IMEx with other protein association datasets"
author: "Pablo Porras"
date: '2016-12-19'
output:
  html_document:
    fig_height: 16
    fig_width: 8
    keep_md: yes
    toc: yes
runtime: shiny
---
```{r set-options, echo=FALSE}
options(width = 80, defaultWidth = 1000, defaultHeight = 1200)
#runtime: shiny
```
Estimating the size of the uncurated interactome
========================================================

### Synopsis

After producing tidy datasets comparing different resources to IMEx data, we put together the data and compare the overlap. 

IMPORTANT: This set of scripts assume the different referenced datasets have been freshly updated. If you need to update results of this set, please re-run the corresponding source as well. 

#### Required libraries
```{r libraries,message=FALSE,warning=FALSE}
# install packages if some are not already installed
packages = c("plyr","dplyr","data.table","UpSetR", "splitstackshape", "ggplot2", "shiny", "htmlwidgets")
if(mean(packages %in% installed.packages()) != 1){
        install.packages(packages[!packages %in% installed.packages()])
}
suppressPackageStartupMessages({
library(plyr)
library(dplyr)
library(data.table)
library(UpSetR)
library(splitstackshape)
library(ggplot2)
library(shiny)
library(htmlwidgets)
})
```
### Part 1: Load datasets

#### IMEx dataset

I select only purely human interactions here (interactions where both proteins are human). 

```{r warning=FALSE,message=FALSE}
imex_full <- fread("../IMEx/results/imex_full.txt", header=T, sep="\t",colClasses="character",data.table = T)
imex_human <- unique(subset(imex_full,taxid_a=="9606" & taxid_b=="9606"))
imex_human$imex <- 1
imex_human_sel <- unique(select(imex_human,pair_id=pair_id_clean,pmid=pubid,imex))
imex_pairs <- unique(select(imex_human,pair_id=pair_id_clean,imex))
imex_pmids <- unique(select(imex_human,pmid=pubid,imex))
```

The dataset contains `r nrow(imex_pairs)` protein interactions recorded in `r nrow(imex_pmids)` publications.

#### Reactome data

```{r, fig.height=8, fig.width=8}
setwd("../reactome_interactions/results/")
system("gunzip -k pairs_pmid_reactome.txt.gz")
reactome_pairs_pmids <- fread("pairs_pmid_reactome.txt",header=T,sep="\t",colClasses=c("character","character","numeric"),data.table = T)
system("rm pairs_pmid_reactome.txt")
setwd("../../dsp_comparison/")

reactome_pairs <- unique(select(reactome_pairs_pmids,pair_id,reactome))
reactome_pmids <- unique(select(reactome_pairs_pmids,pmid,reactome))
```

The reactome dataset contains `r nrow(reactome_pairs)` protein associations recorded in `r nrow(reactome_pmids)` publications. 

#### Text-mining EPMC data

```{r, fig.height=8, fig.width=8}
setwd("../epmc_text_mining/results/")
system("gunzip -k pairs_pmids_tm.txt.gz")
tm_pairs_pmids <- fread("pairs_pmids_tm.txt",header=T,sep="\t",colClasses=c("character","character","numeric"),data.table = T)
system("rm pairs_pmids_tm.txt")
setwd("../../dsp_comparison/")

tm_pairs_pmids_sel <- unique(select(tm_pairs_pmids,pair_id,pmid,tm_epmc=tm))
tm_pairs <- unique(select(tm_pairs_pmids,pair_id,tm_epmc=tm))
tm_pmids <- unique(select(tm_pairs_pmids,pmid,tm_epmc=tm))
```

The text-mining EPMC dataset contains `r nrow(tm_pairs)` protein associations recorded in `r nrow(tm_pmids)` publications.

#### IID predictions data

```{r, fig.height=8, fig.width=8}
iid_pred_pairs <- fread("../iid_predictions/results/pairs_iid_pred.txt",header=T,sep="\t",colClasses=c("character","numeric"),data.table=T)
```

The IID-predictions dataset contains `r nrow(iid_pred_pairs)` protein associations.

#### Text-mining EVEX data

```{r, fig.height=8, fig.width=8}
setwd("../EVEX/results/")
EVEX_pairs_pmids <- fread("pairs_pmids_EVEX_shallow.txt",header=T,sep="\t",colClasses=c("character","character","character","character","character","numeric"),data.table = T)
setwd("../../dsp_comparison/")

EVEX_pairs_pmids_sel <- unique(select(EVEX_pairs_pmids, pair_id=pair_id_clean, pmid=pubid,EVEX))
EVEX_pairs <- unique(select(EVEX_pairs_pmids, pair_id=pair_id_clean,EVEX))
EVEX_pmids <- unique(select(EVEX_pairs_pmids, pmid=pubid,EVEX))
```

The text-mining EVEX dataset contains `r nrow(EVEX_pairs)` protein associations recorded in `r nrow(EVEX_pmids)` publications.

#### BioGRID data

```{r, fig.height=8, fig.width=8}
setwd("../BioGRID/results/")
BioGRID_pairs_pmids <- fread("pairs_pmids_biogrid.txt",header=T,sep="\t",colClasses=c("character","character","numeric"),data.table = T)
setwd("../../dsp_comparison/")

BioGRID_pairs_pmids_sel <- unique(select(BioGRID_pairs_pmids, pair_id=pair_id_clean, pmid=pubid, BioGRID = biogrid))
BioGRID_pairs <- unique(select(BioGRID_pairs_pmids, pair_id=pair_id_clean,BioGRID = biogrid))
BioGRID_pmids <- unique(select(BioGRID_pairs_pmids, pmid=pubid,BioGRID = biogrid))
```

The BioGRID dataset contains `r nrow(BioGRID_pairs)` protein associations recorded in `r nrow(BioGRID_pmids)` publications.

#### GO IPI data (EBI_GOA_nonIntAct)

```{r, fig.height=8, fig.width=8}
setwd("../GO_IPI/results/")
GO_IPI_pairs_pmids <- fread("pairs_pmids_EBI_GOA_nonIntAct.txt",header=T,sep="\t",colClasses=c("character","character","numeric"),data.table = T)
setwd("../../dsp_comparison/")

GO_IPI_pairs_pmids_sel <- unique(select(GO_IPI_pairs_pmids, pair_id=pair_id_clean, pmid=pubid, GO_IPI = EBI_GOA_nonIntAct))
GO_IPI_pairs <- unique(select(GO_IPI_pairs_pmids, pair_id=pair_id_clean,GO_IPI = EBI_GOA_nonIntAct))
GO_IPI_pmids <- unique(select(GO_IPI_pairs_pmids, pmid=pubid,GO_IPI = EBI_GOA_nonIntAct))
```

The BioGRID dataset contains `r nrow(GO_IPI_pairs)` protein associations recorded in `r nrow(GO_IPI_pmids)` publications.

#### OmniPath interaction data 

```{r, fig.height=8, fig.width=8}
setwd("../OmniPath/results/")
OmniPath_interaction_pairs_pmids <- fread("pairs_pmids_OmniPath_interactions_minimal.txt",header=T,sep="\t",colClasses=c("character","character","character","character","character","numeric"),data.table = T)
setwd("../../dsp_comparison/")

OmniPath_interaction_pairs_pmids_sel <- unique(select(OmniPath_interaction_pairs_pmids, pair_id=pair_id_clean, pmid=pubid, OmniPath_interactions))
OmniPath_interaction_pairs <- unique(select(OmniPath_interaction_pairs_pmids, pair_id=pair_id_clean,OmniPath_interactions))
OmniPath_interaction_pmids <- unique(select(OmniPath_interaction_pairs_pmids, pmid=pubid,OmniPath_interactions))
```

The BioGRID dataset contains `r nrow(OmniPath_interaction_pairs)` protein associations recorded in `r nrow(OmniPath_interaction_pmids)` publications.

#### OmniPath ptm (post-translational modifications) data 

```{r, fig.height=8, fig.width=8}
setwd("../OmniPath/results/")
OmniPath_ptm_pairs_pmids <- fread("pairs_pmids_OmniPath_ptm_interactions_minimal.txt",header=T,sep="\t",colClasses=c("character","character","character","character","character","numeric"),data.table = T)
setwd("../../dsp_comparison/")

OmniPath_ptm_pairs_pmids_sel <- unique(select(OmniPath_ptm_pairs_pmids, pair_id=pair_id_clean, pmid=pubid, OmniPath_ptm))
OmniPath_ptm_pairs <- unique(select(OmniPath_ptm_pairs_pmids, pair_id=pair_id_clean,OmniPath_ptm))
OmniPath_ptm_pmids <- unique(select(OmniPath_ptm_pairs_pmids, pmid=pubid,OmniPath_ptm))
```

The BioGRID dataset contains `r nrow(OmniPath_ptm_pairs)` protein associations recorded in `r nrow(OmniPath_ptm_pmids)` publications.


### Part 2: Generating comparison dataset at the pair level

```{r, fig.height=8, fig.width=8}
# Code below generates (to allow any number and any column names) and evaluates this:
# paste0("all_df <- list(",paste0(grep("_pairs$", ls(), value = T), collapse= ","),")")
# eval(parse(text=paste0("all_df <- list(",paste0(grep("_pairs$", ls(), value = T), collapse= ","),")")))
# results in errors upstream

all_df <- list(imex_pairs,reactome_pairs,tm_pairs,iid_pred_pairs, EVEX_pairs, BioGRID_pairs, GO_IPI_pairs, OmniPath_interaction_pairs, OmniPath_ptm_pairs)

comp_table <- Reduce(function(...) merge(..., all=TRUE), all_df)

# I clean and replace all NAs if present.

comp_table_final <- comp_table
comp_table_final[is.na(comp_table_final <- comp_table)] <- 0
comp_table_final = unique(comp_table_final)
fwrite(comp_table_final,"./results/comp_table_final.txt",col.names=T,row.names=F,sep="\t",quote=F)
system("gzip ./results/comp_table_final.txt --force")
unlink("./results/comp_table_final.txt")
```

The comparison set gives a total number of `r nrow(comp_table_final)` potentially interacting pairs, of which `r nrow(comp_table_final[comp_table_final$imex==0,])` (`r round(nrow(comp_table_final[comp_table_final$imex==0,])*100/nrow(comp_table_final),2)`%) are not curated in IMEx. 

I produce a plot with the summary of the overlap between the different datasets evaluated. 

```{r visualize_overlaps, fig.height=6, fig.width=8, results='hide'}
groups = colnames(comp_table_final)[2:ncol(comp_table_final)]
# generate expression like this "comp_table_final[, overlaps := paste0(imex,reactome,tm_epmc,iid_pred,EVEX,BioGRID,GO_IPI,OmniPath_interactions,OmniPath_ptm)]" and evaluate it - this way the code is independent of column names
eval(parse(text=paste0("comp_table_final[, overlaps := paste0(",paste0(groups, collapse= ","),")]")))
eval(parse(text=paste0("comp_table_final[, N_overlaps := sum(",paste0(groups, collapse= ","),"), by = pair_id]")))

comp_table_final[, N_per_overlaps := .N, by = overlaps]
comp_table_final[, N_per_N_overlaps := .N, by = N_overlaps]

N_overlaps = unique(comp_table_final[,.(N_overlaps, N_per_N_overlaps)])
N_overlaps = N_overlaps[order(N_per_N_overlaps, decreasing = T),]
qplot(label = N_overlaps$N_per_N_overlaps, y = N_overlaps$N_per_N_overlaps, x = N_overlaps$N_overlaps,  geom = "text") + scale_y_log10(labels = 10^c(1:7), breaks = 10^c(1:7)) +
        ggtitle("The number of interacting pairs and the number of resources \n the pairs are shared between") + ylab("the number of interacting pairs, log10 scale")+ xlab("the number of resources")+scale_x_continuous(labels = N_overlaps$N_overlaps, breaks = N_overlaps$N_overlaps)

overlaps = unique(comp_table_final[,.(overlaps, N_per_overlaps)])
overlaps = overlaps[order(N_per_overlaps, decreasing = T),]
```

### Interactive plot of the overlaps between selected resources (interacting pairs)

```{r Shiny_interactions, message=F, warning=F, echo=F}
# shiny applets share the variable names across the document, so for shiny applets to work independently they must have orthogonal names
# specify the name of the table
table_name1 = "comp_table_final"
# specify which type of data is being compared - for display on the plot
type_of_data1 = "interacting pairs" # or "publications" or "interacting pairs and publications"

        fluidRow(
                { 
                        library(ggplot2)
                        library(data.table)
                        library(R.utils)
                        gzfilename = paste0("./results/",table_name1,".txt.gz")
                        filename = paste0(substr(gzfilename, 1, nchar(gzfilename)-3))
                        gunzip(gzfilename, overwrite =T, remove =F)
                        table_final = fread(filename)
                        unlink(filename)
                        groups_int = colnames(table_final)[colnames(table_final) != "pair_id"]
                        # generate expression like this "table_final[, overlaps := paste0(imex,reactome,tm_epmc,iid_pred,EVEX,BioGRID,GO_IPI,OmniPath_interactions,OmniPath_ptm)]" and evaluate it - this way the code is independent of column names
                        eval(parse(text=paste0("table_final[, overlaps := paste0(",paste0(groups_int, collapse= ","),")]")))
                        eval(parse(text=paste0("table_final[, N_overlaps := sum(",paste0(groups_int, collapse= ","),"), by = pair_id]")))
                        table_final[, N_per_overlaps := .N, by = overlaps]
                        table_final[, N_per_N_overlaps := .N, by = N_overlaps]

                        overlaps = unique(table_final[,.(overlaps, N_per_overlaps)])
                        overlaps = overlaps[order(N_per_overlaps, decreasing = T),]
                        ""
                },
                
                        column(4,
                           selectInput("groups_sel1", "Choose a dataset 1:",
                                choices = groups_int, selected = groups_int[1])
                        ),
                        column(4,
                           selectInput("groups_sel2", "Choose a dataset 2:",
                                choices = groups_int, selected = groups_int[2])
                        ),
                        column(4,
                           selectInput("groups_sel3", "Choose a dataset 3:",
                           choices = groups_int, selected = groups_int[3])
                        ),
                        column(4,
                           selectInput("groups_sel4", "Choose a dataset 4:",
                           choices = groups_int, selected = groups_int[4]))
    )
        
#mainPanel(
#        tabsetPanel(
#    tabPanel("simplePlot", plotOutput("simplePlot")),
#    tabPanel("detailedPlot", plotOutput("detailedPlot"))), width = 12
#  )

# Plot1: labels look like this "0101"
# output$simplePlot <-
        renderPlot({
        
     groups_sel1_4 = c(input$groups_sel1,input$groups_sel2,input$groups_sel3,input$groups_sel4)
     sel1 = which(colnames(table_final) == input$groups_sel1)
     sel2 = which(colnames(table_final) == input$groups_sel2)
     sel3 = which(colnames(table_final) == input$groups_sel3)
     sel4 = which(colnames(table_final) == input$groups_sel4)
     sel = c(sel1,sel2,sel3,sel4)
     sel_plot = table_final[,groups_sel1_4,with = FALSE]
     setnames(sel_plot, colnames(sel_plot), c("V1", "V2", "V3", "V4"))
     sel_plot[, overlaps := paste0(V1, V2, V3, V4)]
     sel_plot[, N_per_overlaps := .N, by = overlaps]
     sel_plot[, N_per_N_overlaps := .N, by = N_per_overlaps]
     if("imex" %in% groups_sel1_4) {
     inIMEx = sel_plot[, which(groups_sel1_4 == "imex"),with = FALSE]
     sel_plot[, inIMEx := inIMEx]
     }
     if(!"imex" %in% groups_sel1_4) {
     sel_plot[, inIMEx := 0]
     }
     overlaps = unique(sel_plot[,.(overlaps, N_per_overlaps, inIMEx)])
     overlaps = overlaps[order(N_per_overlaps, decreasing = T),]

     qplot(label = overlaps$overlaps, y = overlaps$N_per_overlaps, x = overlaps$overlaps, color = overlaps$inIMEx,  geom = "point") + scale_y_log10() +
        ggtitle(paste0("The number of ", type_of_data1 ," found \n in the combination of resources the ", type_of_data1 ," are shared between")) + ylab(paste0("the number of ", type_of_data1 ,", log10 scale"))+ xlab("the combination of resources")+
             geom_text(aes(y = overlaps$N_per_overlaps+overlaps$N_per_overlaps*0.3, label = overlaps$N_per_overlaps))+
             geom_text(aes(y = overlaps$N_per_overlaps-overlaps$N_per_overlaps*0.3, label = overlaps$overlaps))+
             geom_text(aes(x=14,y=max(overlaps$N_per_overlaps)-max(overlaps$N_per_overlaps)*0.5,label = paste(input$groups_sel1, "\n", input$groups_sel2, "\n", input$groups_sel3, "\n", input$groups_sel4, "\n")),colour = "black")+ theme(legend.position="none")
     }, width = 800, height = 600)
        
# Plot2: labels explain the content
# output$detailedPlot <-
        renderPlot({
        groups_sel1_4 = c(input$groups_sel1,input$groups_sel2,input$groups_sel3,input$groups_sel4)
     sel1 = which(colnames(table_final) == input$groups_sel1)
     sel2 = which(colnames(table_final) == input$groups_sel2)
     sel3 = which(colnames(table_final) == input$groups_sel3)
     sel4 = which(colnames(table_final) == input$groups_sel4)
     sel = c(sel1,sel2,sel3,sel4)
     sel_plot = table_final[,groups_sel1_4,with = FALSE]
     setnames(sel_plot, colnames(sel_plot), c("V1", "V2", "V3", "V4"))
     
     sel_plot[V1 == 1, V1_n := input$groups_sel1];sel_plot[V1 == 0, V1_n := "none"]
     sel_plot[V2 == 1, V2_n := input$groups_sel2];sel_plot[V2 == 0, V2_n := "none"]
     sel_plot[V3 == 1, V3_n := input$groups_sel3];sel_plot[V3 == 0, V3_n := "none"]
     sel_plot[V4 == 1, V4_n := input$groups_sel4];sel_plot[V4 == 0, V4_n := "none"]
     
     sel_plot[, overlap_names := paste(V1_n, V2_n, V3_n, V4_n, sep = "_g_")]
     sel_plot[, overlaps := paste0(V1, V2, V3, V4)]
     sel_plot[, N_per_overlaps := .N, by = overlaps]
     sel_plot[, N_per_N_overlaps := .N, by = N_per_overlaps]
     
     if("imex" %in% groups_sel1_4) {which(groups_sel1_4 == "imex")
     inIMEx = sel_plot[, which(groups_sel1_4 == "imex"),with = FALSE]
     sel_plot[, inIMEx := inIMEx]
     }
     if(!"imex" %in% groups_sel1_4) {which(groups_sel1_4 == "imex")
     inIMEx = sel_plot[, which(groups_sel1_4 == "imex"),with = FALSE]
     sel_plot[, inIMEx := 0]
     }

     overlaps = unique(sel_plot[,.(overlaps, N_per_overlaps,inIMEx, overlap_names)])
     overlaps = overlaps[order(N_per_overlaps, decreasing = T),]
     overlaps[, overlap_names := gsub("none_g_","",overlap_names)]
     overlaps[, overlap_names := gsub("_g_none_g_","_g_",overlap_names)]
     overlaps[, overlap_names := gsub("_g_none","",overlap_names)]
     overlaps[, overlap_names := gsub("_g_","\n",overlap_names)]
     qplot(label = overlaps$overlaps, y = overlaps$N_per_overlaps, x = overlaps$overlaps, color = overlaps$inIMEx,  geom = "point") + scale_y_log10() +
        ggtitle(paste0("The number of ", type_of_data1 ," found \n in the combination of resources the ", type_of_data1 ," are shared between")) + ylab(paste0("the number of ", type_of_data1 ,", log10 scale"))+ xlab("the combination of resources")+
             geom_text(aes(y = overlaps$N_per_overlaps+overlaps$N_per_overlaps*0.3, label = overlaps$N_per_overlaps))+
             geom_text(aes(y = overlaps$N_per_overlaps-overlaps$N_per_overlaps*0.3, x = overlaps$overlaps, label = overlaps$overlap_names))+
             geom_text(aes(x=14,y=max(overlaps$N_per_overlaps)-max(overlaps$N_per_overlaps)*0.5,label = paste(input$groups_sel1, "\n", input$groups_sel2, "\n", input$groups_sel3, "\n", input$groups_sel4, "\n")),colour = "black")+ theme(legend.position="none")
     }, width = 800, height = 600)

```



##### Figure 1: Comparison between different protein association datasets
```{r echo=FALSE, fig.width=10,fig.height=6, eval=F}
upset(comp_table_final, 
      nsets = 4, 
      point.size = 6, 
      line.size = 2, 
      mainbar.y.label = "Common protein pairs", 
      sets.x.label = "Nr of protein pairs in dataset", 
      order.by="freq",
      decreasing=FALSE,
      queries = list(
              list(query = intersects, params = list("reactome","iid_pred","tm_epmc"), color = "blue", active = T),
              list(query = intersects, params = list("iid_pred","tm_epmc"), color= "cornflowerblue",active = T),
              list(query = intersects, params = list("reactome","iid_pred"), color= "cornflowerblue",active = T),
              list(query = intersects, params = list("reactome","tm_epmc"), color= "cornflowerblue",active = T),
              list(query = intersects, params = list("imex","iid_pred","reactome","tm_epmc"), color= "darkorange2",active = T),
              list(query = intersects, params = list("imex","reactome","tm_epmc"), color= "orange1",active = T),
              list(query = intersects, params = list("imex","iid_pred","tm_epmc"), color= "orange1",active = T),
              list(query = intersects, params = list("imex","iid_pred","reactome"), color= "orange1",active = T),
              list(query = intersects, params = list("imex","iid_pred"), color= "lightgoldenrod1",active = T),
              list(query = intersects, params = list("imex","reactome"), color= "lightgoldenrod1",active = T),
              list(query = intersects, params = list("imex","tm_epmc"), color= "lightgoldenrod1",active = T),
              list(query = intersects, params = list("imex"), color= "gray70",active = T),
              list(query = intersects, params = list("reactome"), color= "gray70",active = T),
              list(query = intersects, params = list("iid_pred"), color= "gray70",active = T),
              list(query = intersects, params = list("tm_epmc"), color= "gray70",active = T)))
```



##### Figure 2: Intersection between different protein association datasets  
A plot showing exclusively the intersections.
```{r shiny_upset_int,echo=FALSE,fig.width=10,fig.height=10, eval=T}

table_name1 = "comp_table_final"

fluidRow(
                { 
                        library(ggplot2)
                        library(data.table)
                        library(R.utils)
                        library(UpSetR)
                        gzfilename = paste0("./results/",table_name1,".txt.gz")
                        filename = paste0(substr(gzfilename, 1, nchar(gzfilename)-3))
                        gunzip(gzfilename, overwrite =T, remove =F)
                        table_final_up = fread(filename)
                        unlink(filename)
                        groups_up_int = colnames(table_final_up)[2:ncol(table_final_up)]
                        ""
                        },
                
                        column(4,
                           selectInput("groups_up_select1", "Choose a dataset 1:",
                                choices = groups_up_int, selected = groups_up_int[1])
                        ),
                        column(4,
                           selectInput("groups_up_select2", "Choose a dataset 2:",
                                choices = groups_up_int, selected = groups_up_int[2])
                        ),
                        column(4,
                           selectInput("groups_up_select3", "Choose a dataset 4:",
                           choices = groups_up_int, selected = groups_up_int[3])
                        ),
                        column(4,
                           selectInput("groups_up_select4", "Choose a dataset 3:",
                           choices = groups_up_int, selected = groups_up_int[4]))
)

renderPlot({
        
     sel_up1 = input$groups_up_select1
     sel_up2 = input$groups_up_select2
     sel_up3 = input$groups_up_select3
     sel_up4 = input$groups_up_select4
     
upset(table_final_up, 
      nsets = 4, 
      point.size = 6, 
      line.size = 2, 
      mainbar.y.label = paste0("Common interacting pairs") , 
      sets.x.label = "Nr of protein pairs in dataset",
      order.by="freq",
      decreasing=FALSE,
      queries = list(
              list(query = intersects, params = list(sel_up2,sel_up3,sel_up4), color = "blue", active = T),
              list(query = intersects, params = list(sel_up3,sel_up4), color= "cornflowerblue",active = T),
              list(query = intersects, params = list(sel_up2,sel_up3), color= "cornflowerblue",active = T),
              list(query = intersects, params = list(sel_up2,sel_up4), color= "cornflowerblue",active = T),
              list(query = intersects, params = list(sel_up1,sel_up3,sel_up2,sel_up4), color= "darkorange2",active = T),
              list(query = intersects, params = list(sel_up1,sel_up2,sel_up4), color= "orange1",active = T),
              list(query = intersects, params = list(sel_up1,sel_up3,sel_up4), color= "orange1",active = T),
              list(query = intersects, params = list(sel_up1,sel_up3,sel_up2), color= "orange1",active = T),
              list(query = intersects, params = list(sel_up1,sel_up3), color= "lightgoldenrod2",active = T),
              list(query = intersects, params = list(sel_up1,sel_up2), color= "lightgoldenrod2",active = T),
              list(query = intersects, params = list(sel_up1,sel_up4), color= "lightgoldenrod2",active = T)),
      intersections = list(
              list(sel_up2,sel_up3,sel_up4),
              list(sel_up3,sel_up4),
              list(sel_up2,sel_up3),
              list(sel_up2,sel_up4),
              list(sel_up1,sel_up3,sel_up2,sel_up4),
              list(sel_up1,sel_up2,sel_up4),
              list(sel_up1,sel_up3,sel_up4),
              list(sel_up1,sel_up3,sel_up2),
              list(sel_up1,sel_up3),
              list(sel_up1,sel_up2),
              list(sel_up1,sel_up4)))
}
, width = 800, height = 600)
```



### Part 3: Generating comparison dataset at the publication level

```{r, eval=T}
allpub_df <- list(imex_pmids,reactome_pmids,tm_pmids, EVEX_pmids, BioGRID_pmids, GO_IPI_pmids, OmniPath_interaction_pmids, OmniPath_ptm_pmids)

pubcomp_table <- Reduce(function(...) merge(..., all=TRUE), allpub_df)

# I clean and replace all NAs if present.

pubcomp_table_final <- pubcomp_table
pubcomp_table_final[is.na(pubcomp_table_final <- pubcomp_table)] <- 0
fwrite(pubcomp_table_final,"./results/pubcomp_table_final.txt",col.names=T,row.names=F,sep="\t",quote=F)
system("gzip ./results/pubcomp_table_final.txt --force")
```

The comparison set gives a total number of `r nrow(pubcomp_table_final)` publications, of which `r nrow(pubcomp_table_final[pubcomp_table_final$imex==0,])` (`r round(nrow(pubcomp_table_final[pubcomp_table_final$imex==0,])*100/nrow(pubcomp_table_final),2)`%) are not curated in IMEx. 

I produce a plot with of the overlap between the different datasets. 

```{r visualize_overlaps_publications, fig.height=6, fig.width=8, results='hide'}
pubgroups = colnames(pubcomp_table_final)[2:ncol(pubcomp_table_final)]
pubcomp_table_final[, puboverlaps := paste0(imex, reactome, tm_epmc, EVEX, BioGRID, GO_IPI, OmniPath_interactions, OmniPath_ptm)]
pubcomp_table_final[, N_puboverlaps := sum(imex, reactome, tm_epmc, EVEX, BioGRID, GO_IPI, OmniPath_interactions, OmniPath_ptm), by = pmid]
pubcomp_table_final[, N_per_puboverlaps := .N, by = puboverlaps]
pubcomp_table_final[, N_per_N_puboverlaps := .N, by = N_puboverlaps]

N_puboverlaps = unique(pubcomp_table_final[,.(N_puboverlaps, N_per_N_puboverlaps)])
N_puboverlaps = N_puboverlaps[order(N_per_N_puboverlaps, decreasing = T),]
qplot(label = N_puboverlaps$N_per_N_puboverlaps, y = N_puboverlaps$N_per_N_puboverlaps, x = N_puboverlaps$N_puboverlaps,  geom = "text") + scale_y_log10(labels = 10^c(1:7), breaks = 10^c(1:7)) +
        ggtitle("The number of publications and the number of resources \n the publications are shared between") + ylab("the number of publications, log10 scale")+ xlab("the number of resources")+scale_x_continuous(labels = N_puboverlaps$N_puboverlaps, breaks = N_puboverlaps$N_puboverlaps)
```



### Interactive plot of the overlaps between selected resources (publications)

```{r Shiny_publications, message=F, warning=F, echo=F, eval=T}
# specify the name of the table
table_name2 = "pubcomp_table_final"
# specify which type of data is being compared - for display on the plot
type_of_data2 = "publications" # or "publications" or "interacting pairs and publications"
        fluidRow(
                { 
                        library(ggplot2)
                        library(data.table)
                        library(R.utils)
                        pubgzpubfilename = paste0("./results/",table_name2,".txt.gz")
                        pubfilename = paste0(substr(pubgzpubfilename, 1, nchar(pubgzpubfilename)-3))
                        gunzip(pubgzpubfilename, overwrite =T, remove =F)
                        table_pub_final = fread(pubfilename)
                        unlink(pubfilename)
                        groups_pub = colnames(table_pub_final)[colnames(table_pub_final) != "pmid"]
                        # generate expression like this "table_pub_final[, pub_overlaps := paste0(imex,reactome,tm_epmc,iid_pred,EVEX,BioGRID,GO_IPI,OmniPath_interactions,OmniPath_ptm)]" and evaluate it - this way the code is independent of column names
                        eval(parse(text=paste0("table_pub_final[, pub_overlaps := paste0(",paste0(groups_pub, collapse= ","),")]")))
                        eval(parse(text=paste0("table_pub_final[, N_pub_overlaps := sum(",paste0(groups_pub, collapse= ","),"), by = pmid]")))
                        table_pub_final[, N_per_pub_overlaps := .N, by = pub_overlaps]
                        table_pub_final[, N_per_N_pub_overlaps := .N, by = N_pub_overlaps]

                        pub_overlaps = unique(table_pub_final[,.(pub_overlaps, N_per_pub_overlaps)])
                        pub_overlaps = pub_overlaps[order(N_per_pub_overlaps, decreasing = T),]
                        ""
                },
                
                        column(4,
                           selectInput("pub_groups_pub_sel11", "Choose a dataset 1:",
                                choices = groups_pub, selected = groups_pub[1])
                        ),
                        column(4,
                           selectInput("pub_groups_pub_sel12", "Choose a dataset 2:",
                                choices = groups_pub, selected = groups_pub[2])
                        ),
                        column(4,
                           selectInput("pub_groups_pub_sel13", "Choose a dataset 3:",
                           choices = groups_pub, selected = groups_pub[3])
                        ),
                        column(4,
                           selectInput("pub_groups_pub_sel14", "Choose a dataset 4:",
                           choices = groups_pub, selected = groups_pub[4]))
    )
        
#mainPanel(
#        tabsetPanel(
#    tabPanel("simplePlot", plotOutput("simplePlot")),
#    tabPanel("detailedPlot", plotOutput("detailedPlot"))), width = 12
#  )

# Plot1: labels look like this "0101"
# output$simplePlot <-
        renderPlot({
        
     pub_groups_pub_sel11_4 = c(input$pub_groups_pub_sel11,input$pub_groups_pub_sel12,input$pub_groups_pub_sel13,input$pub_groups_pub_sel14)
     pub_sel1 = which(colnames(table_pub_final) == input$pub_groups_pub_sel11)
     pub_sel2 = which(colnames(table_pub_final) == input$pub_groups_pub_sel12)
     pub_sel3 = which(colnames(table_pub_final) == input$pub_groups_pub_sel13)
     pub_sel4 = which(colnames(table_pub_final) == input$pub_groups_pub_sel14)
     pub_sel = c(pub_sel1,pub_sel2,pub_sel3,pub_sel4)
     pub_sel_plot = table_pub_final[,pub_groups_pub_sel11_4,with = FALSE]
     setnames(pub_sel_plot, colnames(pub_sel_plot), c("V1", "V2", "V3", "V4"))
     pub_sel_plot[, pub_overlaps := paste0(V1, V2, V3, V4)]
     pub_sel_plot[, N_per_pub_overlaps := .N, by = pub_overlaps]
     pub_sel_plot[, N_per_N_pub_overlaps := .N, by = N_per_pub_overlaps]
     if("imex" %in% pub_groups_pub_sel11_4) {
     inIMEx = pub_sel_plot[, which(pub_groups_pub_sel11_4 == "imex"),with = FALSE]
     pub_sel_plot[, inIMEx := inIMEx]
     }
     if(!"imex" %in% pub_groups_pub_sel11_4) {
     pub_sel_plot[, inIMEx := 0]
     }
     pub_overlaps = unique(pub_sel_plot[,.(pub_overlaps, N_per_pub_overlaps, inIMEx)])
     pub_overlaps = pub_overlaps[order(N_per_pub_overlaps, decreasing = T),]

     qplot(label = pub_overlaps$pub_overlaps, y = pub_overlaps$N_per_pub_overlaps, x = pub_overlaps$pub_overlaps, color = pub_overlaps$inIMEx,  geom = "point") + scale_y_log10() +
        ggtitle(paste0("The number of ", type_of_data2 ," found \n in the combination of resources the ", type_of_data2 ," are shared between")) + ylab(paste0("the number of ", type_of_data2 ,", log10 scale"))+ xlab("the combination of resources")+
             geom_text(aes(y = pub_overlaps$N_per_pub_overlaps+pub_overlaps$N_per_pub_overlaps*0.3, label = pub_overlaps$N_per_pub_overlaps))+
             geom_text(aes(y = pub_overlaps$N_per_pub_overlaps-pub_overlaps$N_per_pub_overlaps*0.3, label = pub_overlaps$pub_overlaps))+
             geom_text(aes(x=14,y=max(pub_overlaps$N_per_pub_overlaps)-max(pub_overlaps$N_per_pub_overlaps)*0.5,label = paste(input$pub_groups_pub_sel11, "\n", input$pub_groups_pub_sel12, "\n", input$pub_groups_pub_sel13, "\n", input$pub_groups_pub_sel14, "\n")),colour = "black")+ theme(legend.position="none")
     }, width = 800, height = 600)
        
# Plot2: labels explain the content
# output$detailedPlot <-
        renderPlot({
        pub_groups_pub_sel11_4 = c(input$pub_groups_pub_sel11,input$pub_groups_pub_sel12,input$pub_groups_pub_sel13,input$pub_groups_pub_sel14)
     pub_sel1 = which(colnames(table_pub_final) == input$pub_groups_pub_sel11)
     pub_sel2 = which(colnames(table_pub_final) == input$pub_groups_pub_sel12)
     pub_sel3 = which(colnames(table_pub_final) == input$pub_groups_pub_sel13)
     pub_sel4 = which(colnames(table_pub_final) == input$pub_groups_pub_sel14)
     pub_sel = c(pub_sel1,pub_sel2,pub_sel3,pub_sel4)
     pub_sel_plot = table_pub_final[,pub_groups_pub_sel11_4,with = FALSE]
     setnames(pub_sel_plot, colnames(pub_sel_plot), c("V1", "V2", "V3", "V4"))
     
     pub_sel_plot[V1 == 1, V1_n := input$pub_groups_pub_sel11];pub_sel_plot[V1 == 0, V1_n := "none"]
     pub_sel_plot[V2 == 1, V2_n := input$pub_groups_pub_sel12];pub_sel_plot[V2 == 0, V2_n := "none"]
     pub_sel_plot[V3 == 1, V3_n := input$pub_groups_pub_sel13];pub_sel_plot[V3 == 0, V3_n := "none"]
     pub_sel_plot[V4 == 1, V4_n := input$pub_groups_pub_sel14];pub_sel_plot[V4 == 0, V4_n := "none"]
     
     pub_sel_plot[, overlap_names := paste(V1_n, V2_n, V3_n, V4_n, sep = "_g_")]
     pub_sel_plot[, pub_overlaps := paste0(V1, V2, V3, V4)]
     pub_sel_plot[, N_per_pub_overlaps := .N, by = pub_overlaps]
     pub_sel_plot[, N_per_N_pub_overlaps := .N, by = N_per_pub_overlaps]
     
     if("imex" %in% pub_groups_pub_sel11_4) {which(pub_groups_pub_sel11_4 == "imex")
     inIMEx = pub_sel_plot[, which(pub_groups_pub_sel11_4 == "imex"),with = FALSE]
     pub_sel_plot[, inIMEx := inIMEx]
     }
     if(!"imex" %in% pub_groups_pub_sel11_4) {which(pub_groups_pub_sel11_4 == "imex")
     inIMEx = pub_sel_plot[, which(pub_groups_pub_sel11_4 == "imex"),with = FALSE]
     pub_sel_plot[, inIMEx := 0]
     }

     pub_overlaps = unique(pub_sel_plot[,.(pub_overlaps, N_per_pub_overlaps,inIMEx, overlap_names)])
     pub_overlaps = pub_overlaps[order(N_per_pub_overlaps, decreasing = T),]
     pub_overlaps[, overlap_names := gsub("none_g_","",overlap_names)]
     pub_overlaps[, overlap_names := gsub("_g_none_g_","_g_",overlap_names)]
     pub_overlaps[, overlap_names := gsub("_g_none","",overlap_names)]
     pub_overlaps[, overlap_names := gsub("_g_","\n",overlap_names)]
     qplot(label = pub_overlaps$pub_overlaps, y = pub_overlaps$N_per_pub_overlaps, x = pub_overlaps$pub_overlaps, color = pub_overlaps$inIMEx,  geom = "point") + scale_y_log10() +
        ggtitle(paste0("The number of ", type_of_data2 ," found \n in the combination of resources the ", type_of_data2 ," are shared between")) + ylab(paste0("the number of ", type_of_data2 ,", log10 scale"))+ xlab("the combination of resources")+
             geom_text(aes(y = pub_overlaps$N_per_pub_overlaps+pub_overlaps$N_per_pub_overlaps*0.3, label = pub_overlaps$N_per_pub_overlaps))+
             geom_text(aes(y = pub_overlaps$N_per_pub_overlaps-pub_overlaps$N_per_pub_overlaps*0.3, x = pub_overlaps$pub_overlaps, label = pub_overlaps$overlap_names))+
             geom_text(aes(x=14,y=max(pub_overlaps$N_per_pub_overlaps)-max(pub_overlaps$N_per_pub_overlaps)*0.5,label = paste(input$pub_groups_pub_sel11, "\n", input$pub_groups_pub_sel12, "\n", input$pub_groups_pub_sel13, "\n", input$pub_groups_pub_sel14, "\n")),colour = "black")+ theme(legend.position="none")
     }, width = 800, height = 600)
```



##### Figure 3: Comparison between different protein association datasets at the publication level
```{r echo=FALSE, fig.width=10,fig.height=6, eval=F}
upset(pubcomp_table_final, 
      nsets = 3, 
      point.size = 6, 
      line.size = 2, 
      mainbar.y.label = "Common publications", 
      sets.x.label = "Nr of publications in dataset", 
      order.by="freq",
      decreasing=FALSE,
      queries = list(
              list(query = intersects, params = list("reactome","tm_epmc"), color = "blue", active = T),
              list(query = intersects, params = list("imex","reactome","tm_epmc"), color= "darkorange2",active = T),
              list(query = intersects, params = list("imex","reactome"), color= "lightgoldenrod2",active = T),
              list(query = intersects, params = list("imex","tm_epmc"), color= "lightgoldenrod2",active = T),
              list(query = intersects, params = list("imex"), color= "gray70",active = T),
              list(query = intersects, params = list("reactome"), color= "gray70",active = T),
              list(query = intersects, params = list("tm_epmc"), color= "gray70",active = T)))
```

##### Figure 4: Intersection between different protein association datasets at the publication level
A plot showing exclusively the intersections.
```{r shiny_upset_pub,echo=FALSE,fig.width=10,fig.height=10, eval=T}

table_name2 = "pubcomp_table_final"

fluidRow(
                { 
                        library(ggplot2)
                        library(data.table)
                        library(R.utils)
                        pub_up_gzfilename = paste0("./results/",table_name2,".txt.gz")
                        pub_up_filename = paste0(substr(pub_up_gzfilename, 1, nchar(pub_up_gzfilename)-3))
                        gunzip(pub_up_gzfilename, overwrite =T, remove =F)
                        pub_up_table_final = fread(pub_up_filename)
                        unlink(pub_up_filename)
                        pub_up_groups = colnames(pub_up_table_final)[2:ncol(pub_up_table_final)]
                        ""
                        },
                
                        column(4,
                           selectInput("pub_up_groups_select1", "Choose a dataset 1:",
                                choices = pub_up_groups, selected = pub_up_groups[1])
                        ),
                        column(4,
                           selectInput("pub_up_groups_select2", "Choose a dataset 2:",
                                choices = pub_up_groups, selected = pub_up_groups[2])
                        ),
                        column(4,
                           selectInput("pub_up_groups_select3", "Choose a dataset 4:",
                           choices = pub_up_groups, selected = pub_up_groups[3])
                        ),
                        column(4,
                           selectInput("pub_up_groups_select4", "Choose a dataset 3:",
                           choices = pub_up_groups, selected = pub_up_groups[4]))
)

renderPlot({
        
     pub__up_sel1 = input$pub_up_groups_select1
     pub__up_sel2 = input$pub_up_groups_select2
     pub__up_sel3 = input$pub_up_groups_select3
     pub__up_sel4 = input$pub_up_groups_select4
     
upset(pub_up_table_final, 
      nsets = 4, 
      point.size = 6, 
      line.size = 2, 
      mainbar.y.label = "Common publications", 
      sets.x.label = "Nr of publications in dataset",
      order.by="freq",
      decreasing=FALSE,
      queries = list(
              list(query = intersects, params = list(pub__up_sel2,pub__up_sel3,pub__up_sel4), color = "blue", active = T),
              list(query = intersects, params = list(pub__up_sel3,pub__up_sel4), color= "cornflowerblue",active = T),
              list(query = intersects, params = list(pub__up_sel2,pub__up_sel3), color= "cornflowerblue",active = T),
              list(query = intersects, params = list(pub__up_sel2,pub__up_sel4), color= "cornflowerblue",active = T),
              list(query = intersects, params = list(pub__up_sel1,pub__up_sel3,pub__up_sel2,pub__up_sel4), color= "darkorange2",active = T),
              list(query = intersects, params = list(pub__up_sel1,pub__up_sel2,pub__up_sel4), color= "orange1",active = T),
              list(query = intersects, params = list(pub__up_sel1,pub__up_sel3,pub__up_sel4), color= "orange1",active = T),
              list(query = intersects, params = list(pub__up_sel1,pub__up_sel3,pub__up_sel2), color= "orange1",active = T),
              list(query = intersects, params = list(pub__up_sel1,pub__up_sel3), color= "lightgoldenrod2",active = T),
              list(query = intersects, params = list(pub__up_sel1,pub__up_sel2), color= "lightgoldenrod2",active = T),
              list(query = intersects, params = list(pub__up_sel1,pub__up_sel4), color= "lightgoldenrod2",active = T)),
      intersections = list(
              list(pub__up_sel2,pub__up_sel3,pub__up_sel4),
              list(pub__up_sel3,pub__up_sel4),
              list(pub__up_sel2,pub__up_sel3),
              list(pub__up_sel2,pub__up_sel4),
              list(pub__up_sel1,pub__up_sel3,pub__up_sel2,pub__up_sel4),
              list(pub__up_sel1,pub__up_sel2,pub__up_sel4),
              list(pub__up_sel1,pub__up_sel3,pub__up_sel4),
              list(pub__up_sel1,pub__up_sel3,pub__up_sel2),
              list(pub__up_sel1,pub__up_sel3),
              list(pub__up_sel1,pub__up_sel2),
              list(pub__up_sel1,pub__up_sel4)))
}
, width = 800, height = 600)
```

### Part 4: Generating comparison dataset at the pair level taking the publication into account

```{r, eval=T}
prepubpaircomp_table_1 <- unique(merge(imex_human_sel,reactome_pairs_pmids,by=c("pair_id","pmid"),all=T))
prepubpaircomp_table_2 <- unique(merge(prepubpaircomp_table_1,tm_pairs_pmids_sel,by=c("pair_id","pmid"),all=T))
pubpaircomp_table <- unique(merge(prepubpaircomp_table_2,iid_pred_pairs,by=c("pair_id"),all=T))

# I clean and replace all NAs if present.

pubpaircomp_table_form <- pubpaircomp_table
pubpaircomp_table_form[is.na(pubpaircomp_table_form <- pubpaircomp_table)] <- 0
```

The comparison set gives a total number of `r nrow(pubpaircomp_table_form)` protein association pairs, of which `r nrow(pubpaircomp_table_form[pubpaircomp_table_form$imex==0,])` (`r round(nrow(pubpaircomp_table_form[pubpaircomp_table_form$imex==0,])*100/nrow(pubpaircomp_table_form),2)`%) are not curated in IMEx. In all these pairs the publication from which they were derived was also matched, so the overlaps and numbers differ from my previous comparisons. 

I produce a plot with the summary of the overlap between the different datasets evaluated. 


##### Figure 5: Comparison between different protein association datasets at the pair+publication level
```{r echo=FALSE, fig.width=10,fig.height=6, eval=F}
upset(pubpaircomp_table_form, 
      nsets = 4, 
      point.size = 6, 
      line.size = 2, 
      mainbar.y.label = "Common pair/publication combos", 
      sets.x.label = "Nr of pair/publication combos in dataset", 
      order.by="freq",
      decreasing=FALSE,
      queries = list(
              list(query = intersects, params = list("reactome","iid_pred","tm_epmc"), color = "blue", active = T),
              list(query = intersects, params = list("iid_pred","tm_epmc"), color= "cornflowerblue",active = T),
              list(query = intersects, params = list("reactome","iid_pred"), color= "cornflowerblue",active = T),
              list(query = intersects, params = list("reactome","tm_epmc"), color= "cornflowerblue",active = T),
              list(query = intersects, params = list("imex","iid_pred","reactome","tm_epmc"), color= "darkorange2",active = T),
              list(query = intersects, params = list("imex","reactome","tm_epmc"), color= "orange1",active = T),
              list(query = intersects, params = list("imex","iid_pred","tm_epmc"), color= "orange1",active = T),
              list(query = intersects, params = list("imex","iid_pred","reactome"), color= "orange1",active = T),
              list(query = intersects, params = list("imex","iid_pred"), color= "lightgoldenrod2",active = T),
              list(query = intersects, params = list("imex","reactome"), color= "lightgoldenrod2",active = T),
              list(query = intersects, params = list("imex","tm_epmc"), color= "lightgoldenrod2",active = T),
              list(query = intersects, params = list("imex"), color= "gray70",active = T),
              list(query = intersects, params = list("reactome"), color= "gray70",active = T),
              list(query = intersects, params = list("iid_pred"), color= "gray70",active = T),
              list(query = intersects, params = list("tm_epmc"), color= "gray70",active = T)))
```

And again, a sub-plot showing exclusively the intersections, for better comparison.  

##### Figure 6: Intersection between different protein association datasets at the pair+publication level
```{r echo=FALSE,fig.width=10,fig.height=6, eval=F}
upset(pubpaircomp_table_form, 
      nsets = 4, 
      point.size = 6, 
      line.size = 2, 
      mainbar.y.label = "Common pair/publication combos", 
      sets.x.label = "Nr of pair/publication combos in dataset",
      order.by="freq",
      decreasing=FALSE,
      queries = list(
              list(query = intersects, params = list("reactome","iid_pred","tm_epmc"), color = "blue", active = T),
              list(query = intersects, params = list("iid_pred","tm_epmc"), color= "cornflowerblue",active = T),
              list(query = intersects, params = list("reactome","iid_pred"), color= "cornflowerblue",active = T),
              list(query = intersects, params = list("reactome","tm_epmc"), color= "cornflowerblue",active = T),
              list(query = intersects, params = list("imex","iid_pred","reactome","tm_epmc"), color= "darkorange2",active = T),
              list(query = intersects, params = list("imex","reactome","tm_epmc"), color= "orange1",active = T),
              list(query = intersects, params = list("imex","iid_pred","tm_epmc"), color= "orange1",active = T),
              list(query = intersects, params = list("imex","iid_pred","reactome"), color= "orange1",active = T),
              list(query = intersects, params = list("imex","iid_pred"), color= "lightgoldenrod2",active = T),
              list(query = intersects, params = list("imex","reactome"), color= "lightgoldenrod2",active = T),
              list(query = intersects, params = list("imex","tm_epmc"), color= "lightgoldenrod2",active = T)),
      intersections = list(
              list("reactome","iid_pred","tm_epmc"),
              list("iid_pred","tm_epmc"),
              list("reactome","iid_pred"),
              list("reactome","tm_epmc"),
              list("imex","iid_pred","reactome","tm_epmc"),
              list("imex","reactome","tm_epmc"),
              list("imex","iid_pred","tm_epmc"),
              list("imex","iid_pred","reactome"),
              list("imex","iid_pred"),
              list("imex","reactome"),
              list("imex","tm_epmc")))
```

### Part 6: Checking how many of the pair/publication combos involved uncurated proteins

I use a list of proteins non-curated in IMEx produced by Vitalii Kleschevnikov (IntAct group). He produced several versions of this list, using the different versions of the UniProtKB as reference. 

##### Pre-formatting pair/puplication combo comparisons

I need to preformat the 'pubpaircomp_table_final' data frame to compare it with VK lists.

```{r pp_combo_preformat, eval=T}
pubpaircomp_table_check_pt1 <- pubpaircomp_table_form
pubpaircomp_table_check_pt1$prots <- pubpaircomp_table_form$pair_id
pubpaircomp_table_check_pt2 <- cSplit(pubpaircomp_table_check_pt1, "prots", sep = "_", direction = "long")
```

##### Upload IMEx non-curated protein lists

I do not use the list that considers isoforms, since they were not considered in any of the datasets used in the comparison. 
```{r noncur_upload, eval=T}
noimex_spnoisof <- unique(fread("./imex_non_curated/Swissprot_without_isoforms_missing_in_IntAct.txt",header=F,colClasses = "character",data.table = F))

noimex_upnoisof <- unique(fread("./imex_non_curated/UniprotKB_without_isoforms_missing_in_IntAct.txt",header=F,colClasses = "character",data.table = F))
```

##### Check how many of the proteins are missing from IMEx

I will identify those pairs that have proteins that have not been 
```{r missing_check, eval=T}
pubpaircomp_table_check_pt3 <- mutate(pubpaircomp_table_check_pt2,
                                  noncur_prot = 
                                          ifelse(
                                                  prots %in% noimex_upnoisof$V1,
                                                  1,
                                                  0))

pubpaircomp_noncur_pairs <- unique(subset(pubpaircomp_table_check_pt3,noncur_prot==1,select= c("pair_id","noncur_prot")))

pubpaircomp_table_check_pt4 <- unique(merge(pubpaircomp_table_form,pubpaircomp_noncur_pairs,by="pair_id",all.x = T,all.y = F))
pubpaircomp_table_final <- pubpaircomp_table_check_pt4
pubpaircomp_table_final[is.na(pubpaircomp_table_final <- pubpaircomp_table_check_pt4)] <- 0
        
write.table(pubpaircomp_table_final,"./results/pubpaircomp_table_final.txt",col.names=T,row.names=F,sep="\t",quote=F)

setwd("./results")
system("tar -czvf pubpaircomp_table_final.txt.tar.gz pubpaircomp_table_final.txt && rm pubpaircomp_table_final.txt")
setwd("../")
```

##### Generate new 'low-hanging fruit' list

I check the "low hanging fruit": those pair/publication combos that were not found in IMEx, but were identified in the other three resources, plus a column stating if the pair contains non-curated proteins or not. 

```{r final_lhf, eval=T}
lhf <- unique(subset(pubpaircomp_table_final,
                     imex == 0 &
                             reactome == 1 &
                             tm_epmc == 1 &
                             iid_pred == 1))

lhf <- arrange(lhf,desc(noncur_prot),desc(pmid))

lhf_pairs <- unique(select(lhf,pair_id))
lhf_pmids <- unique(select(lhf,pmid))

write.table(lhf,"./results/lhf_list.txt",col.names=T,row.names = F,sep="\t",quote=F)
```

There are `r nrow(lhf_pairs)` pairs recorded in `r nrow(lhf_pmids)` publications that are not curated in IMEx but are found in the other datasets. 


### Part 7: Test sets for Reactome and text-mined datasets

I generate a couple of random samples from the subset of the text-mined and Reactome datasets that is not represented in IMEx. These samples are to be checked by curators to estimate what is the percentage of true/false positives in these datasets. I decide to just provide the PMIDs and request curators to check if the PMID contains interactors and identify the proteins if that's so. 

```{r random_samples, eval=T}
pubpairs_not_imex <- pubpaircomp_table_final[pubpaircomp_table_final$imex==0 & pubpaircomp_table_final$pair_id != "",]
pubpairs_not_imex_sel <- unique(select(pubpairs_not_imex,pmid,pair_id))

publs_not_imex <- unique(select(pubpairs_not_imex,pmid,imex,reactome,tm_epmc,iid_pred,noncur_prot))

set.seed(88)

reactpubl_not_imex <- publs_not_imex[publs_not_imex$reactome==1,]
reactpubl_sample <- reactpubl_not_imex[sample(1:nrow(reactpubl_not_imex),100),]
react_sample <- unique(merge(reactpubl_sample,pubpairs_not_imex_sel,by="pmid"))

tmpubl_not_imex <- publs_not_imex[publs_not_imex$tm_epmc==1,]
tmpubl_sample <- tmpubl_not_imex[sample(1:nrow(tmpubl_not_imex),100),]
tm_sample <- unique(merge(tmpubl_sample,pubpairs_not_imex_sel,by="pmid"))

write.table(reactpubl_sample,"./results/reactpubl_sample.txt",col.names = T,row.names = F,sep="\t",quote=F)
write.table(tmpubl_sample,"./results/tmpubl_sample.txt",col.names = T,row.names = F,sep="\t",quote=F)
```

Low-hanging fruit and Reactome/TM evaluation lists can be checked and accessed at https://docs.google.com/spreadsheets/d/1tL1HtVD3-BxHxKuXbIYhcFjmCptGVEOD5aFJCZw6CZk/edit?usp=sharing. 

********************************************************************************************
