========================================================
width: 1200
height: 1000
font-family: 'Helvetica', 'EBI-Species'
## Comparison of protein association datasets and their enrichment in IMEx curated interactions
## Estimating the size of the uncurated interactome

author: Vitalii Kleshchevnikov, Pablo Porras  
date: 12 April 2017

========================================================

After producing tidy datasets comparing different resources to IMEx data, we put together the data and compare the overlap. 

IMPORTANT: This set of scripts assume the different referenced datasets have been freshly updated. If you need to update results of this set, please re-run the corresponding source as well.

The following datasets are included in the analysis:

```{r setup, include=FALSE}
opts_chunk$set(cache=TRUE, message=FALSE,warning=FALSE, echo=FALSE)
```

```{r libraries}
# install packages if some are not already installed
packages = c("plyr","dplyr","data.table","UpSetR", "splitstackshape", "ggplot2", "shiny", "VennDiagram")
if(mean(packages %in% installed.packages()) != 1){
        install.packages(packages[!packages %in% installed.packages()])
}
suppressPackageStartupMessages({
library(plyr)
library(dplyr)
library(data.table)
library(UpSetR)
library(splitstackshape)
library(ggplot2)
library(shiny)
library(VennDiagram)
})
```

```{r }
imex_full <- fread("../IMEx/results/imex_full.txt", header=T, sep="\t",colClasses="character",data.table = T)
imex_human <- unique(subset(imex_full,taxid_a=="9606" & taxid_b=="9606"))
imex_human$imex <- 1
imex_human_sel <- unique(select(imex_human,pair_id=pair_id_clean,pmid=pubid,imex))
imex_pairs <- unique(select(imex_human,pair_id=pair_id_clean,imex))
imex_pmids <- unique(select(imex_human,pmid=pubid,imex))
```

 - IMEx dataset: contains `r nrow(imex_pairs)` interacting pair of proteins recorded in `r nrow(imex_pmids)` publications.
 
```{r, fig.height=8, fig.width=8, warning=FALSE,message=FALSE, echo=FALSE, cache = T}
setwd("../reactome_interactions/results/")
system("gunzip -k pairs_pmid_reactome.txt.gz")
reactome_pairs_pmids <- fread("pairs_pmid_reactome.txt",header=T,sep="\t",colClasses=c("character","character","numeric"),data.table = T)
system("rm pairs_pmid_reactome.txt")
setwd("../../dsp_comparison/")

reactome_pairs <- unique(select(reactome_pairs_pmids,pair_id,reactome))
reactome_pmids <- unique(select(reactome_pairs_pmids,pmid,reactome))
```

 - Reactome dataset: contains `r nrow(reactome_pairs)` protein associations recorded in `r nrow(reactome_pmids)` publications. 
 
```{r, fig.height=8, fig.width=8, results='hide'}
setwd("../epmc_text_mining/results/")
system("gunzip -k pairs_pmids_tm.txt.gz")
tm_pairs_pmids <- fread("pairs_pmids_tm.txt",header=T,sep="\t",colClasses=c("character","character","numeric"),data.table = T)
system("rm pairs_pmids_tm.txt")
setwd("../../dsp_comparison/")

tm_pairs_pmids_sel <- unique(select(tm_pairs_pmids,pair_id,pmid,tm_epmc=tm))
tm_pairs <- unique(select(tm_pairs_pmids,pair_id,tm_epmc=tm))
tm_pmids <- unique(select(tm_pairs_pmids,pmid,tm_epmc=tm))
```

 - text-mining EPMC dataset contains `r nrow(tm_pairs)` protein associations recorded in `r nrow(tm_pmids)` publications.
 
```{r}
iid_pred_pairs <- fread("../iid_predictions/results/pairs_iid_pred.txt",header=T,sep="\t",colClasses=c("character","numeric"),data.table=T)
```

 - IID-predictions dataset: contains `r nrow(iid_pred_pairs)` protein associations.
 
```{r}
setwd("../EVEX/results/")
EVEX_pairs_pmids <- fread("pairs_pmids_EVEX_shallow.txt",header=T,sep="\t",colClasses=c("character","character","character","character","character","numeric"),data.table = T)
setwd("../../dsp_comparison/")

EVEX_pairs_pmids_sel <- unique(select(EVEX_pairs_pmids, pair_id=pair_id_clean, pmid=pubid,EVEX))
EVEX_pairs <- unique(select(EVEX_pairs_pmids, pair_id=pair_id_clean,EVEX))
EVEX_pmids <- unique(select(EVEX_pairs_pmids, pmid=pubid,EVEX))
```

 - text-mining EVEX dataset: contains `r nrow(EVEX_pairs)` protein associations recorded in `r nrow(EVEX_pmids)` publications.
 
========================================================

Other datasets included in the analysis

```{r}
setwd("../BioGRID/results/")
BioGRID_pairs_pmids <- fread("pairs_pmids_biogrid.txt",header=T,sep="\t",colClasses=c("character","character","numeric"),data.table = T)
setwd("../../dsp_comparison/")

BioGRID_pairs_pmids_sel <- unique(select(BioGRID_pairs_pmids, pair_id=pair_id_clean, pmid=pubid, BioGRID = biogrid))
BioGRID_pairs <- unique(select(BioGRID_pairs_pmids, pair_id=pair_id_clean,BioGRID = biogrid))
BioGRID_pmids <- unique(select(BioGRID_pairs_pmids, pmid=pubid,BioGRID = biogrid))
```

 - BioGRID dataset: contains `r nrow(BioGRID_pairs)` protein associations recorded in `r nrow(BioGRID_pmids)` publications.

```{r}
setwd("../GO_IPI/results/")
GO_IPI_pairs_pmids <- fread("pairs_pmids_EBI_GOA_nonIntAct.txt",header=T,sep="\t",colClasses=c("character","character","numeric"),data.table = T)
setwd("../../dsp_comparison/")

GO_IPI_pairs_pmids_sel <- unique(select(GO_IPI_pairs_pmids, pair_id=pair_id_clean, pmid=pubid, GO_IPI = EBI_GOA_nonIntAct))
GO_IPI_pairs <- unique(select(GO_IPI_pairs_pmids, pair_id=pair_id_clean,GO_IPI = EBI_GOA_nonIntAct))
GO_IPI_pmids <- unique(select(GO_IPI_pairs_pmids, pmid=pubid,GO_IPI = EBI_GOA_nonIntAct))
```

 - GO IPI dataset: contains `r nrow(GO_IPI_pairs)` protein associations recorded in `r nrow(GO_IPI_pmids)` publications.
 
```{r}
setwd("../OmniPath/results/")
OmniPath_interaction_pairs_pmids <- fread("pairs_pmids_OmniPath_interactions_minimal.txt",header=T,sep="\t",colClasses=c("character","character","character","character","character","numeric"),data.table = T)
setwd("../../dsp_comparison/")

setwd("../OmniPath/results/")
OmniPath_ptm_pairs_pmids <- fread("pairs_pmids_OmniPath_ptm_interactions_minimal.txt",header=T,sep="\t",colClasses=c("character","character","character","character","character","numeric"),data.table = T)
setwd("../../dsp_comparison/")

OmniPath_interaction_pairs_pmids_sel <- unique(select(OmniPath_interaction_pairs_pmids, pair_id=pair_id_clean, pmid=pubid, OmniPath_interactions))
OmniPath_interaction_pairs <- unique(select(OmniPath_interaction_pairs_pmids, pair_id=pair_id_clean,OmniPath_interactions))
OmniPath_interaction_pmids <- unique(select(OmniPath_interaction_pairs_pmids, pmid=pubid,OmniPath_interactions))

OmniPath_ptm_pairs_pmids_sel <- unique(select(OmniPath_ptm_pairs_pmids, pair_id=pair_id_clean, pmid=pubid, OmniPath_ptm))
OmniPath_ptm_pairs <- unique(select(OmniPath_ptm_pairs_pmids, pair_id=pair_id_clean,OmniPath_ptm))
OmniPath_ptm_pmids <- unique(select(OmniPath_ptm_pairs_pmids, pmid=pubid,OmniPath_ptm))
```

```{r omnipath_merge}
setnames(OmniPath_interaction_pairs_pmids, colnames(OmniPath_interaction_pairs_pmids)[6], "OmniPath")
setnames(OmniPath_ptm_pairs_pmids, colnames(OmniPath_ptm_pairs_pmids)[6], "OmniPath")
OmniPath_pairs_pmids = rbind(OmniPath_interaction_pairs_pmids, OmniPath_ptm_pairs_pmids)

OmniPath_pairs_pmids_sel <- unique(select(OmniPath_pairs_pmids, pair_id=pair_id_clean, pmid=pubid, OmniPath))
OmniPath_pairs <- unique(select(OmniPath_pairs_pmids, pair_id=pair_id_clean,OmniPath))
OmniPath_pmids <- unique(select(OmniPath_pairs_pmids, pmid=pubid,OmniPath))
```

 - merged OmniPath interaction dataset and OmniPath ptm dataset: contains `r nrow(OmniPath_pairs)` protein associations recorded in `r nrow(OmniPath_pmids)` publications.
 
```{r STRING}
# read STRING_textmining table
setwd("../STRING/results/")
STRING_textmining <- fread("pairs_STRING_textmining.txt",header=T,sep="\t",colClasses=c("character","character","character","character","numeric","character","numeric"),data.table = T)
STRING_textmining_pairs <- unique(select(STRING_textmining, pair_id=pair_id_clean,STRING_textmining))

# read STRING_pathway_inference table
STRING_pathway_inference <- fread("pairs_STRING_pathway_inference.txt",header=T,sep="\t",colClasses=c("character","character","character","character","numeric","character","numeric"),data.table = T)
STRING_pathway_inference_pairs <- unique(select(STRING_pathway_inference, pair_id=pair_id_clean,STRING_pathway_inference))

# read STRING_phylo_predictions table
STRING_phylo_predictions <- fread("pairs_STRING_phylo_predictions.txt",header=T,sep="\t",colClasses=c("character","character","character","character","numeric","character","numeric"),data.table = T)
STRING_phylo_predictions_pairs <- unique(select(STRING_phylo_predictions, pair_id=pair_id_clean,STRING_phylo_predictions))

setwd("../../dsp_comparison/")

```

 - STRING textmining dataset: contains `r nrow(STRING_textmining_pairs)` protein associations.

 - STRING pathway-based inference dataset: contains `r nrow(STRING_pathway_inference)` protein associations.

 - STRING predictions dataset: contains `r nrow(STRING_phylo_predictions_pairs)` protein associations.

Part 1: Generating comparison dataset at the pair level
========================================================
```{r}
# Code below generates (to allow any number and any column names) and evaluates this:
# paste0("all_df <- list(",paste0(grep("_pairs$", ls(), value = T), collapse= ","),")")
# eval(parse(text=paste0("all_df <- list(",paste0(grep("_pairs$", ls(), value = T), collapse= ","),")")))
# results in errors upstream

all_df <- list(imex_pairs,reactome_pairs,tm_pairs,iid_pred_pairs, EVEX_pairs, BioGRID_pairs, GO_IPI_pairs, OmniPath_pairs, STRING_textmining_pairs, STRING_pathway_inference_pairs, STRING_phylo_predictions_pairs)

comp_table <- Reduce(function(...) merge(..., all=TRUE), all_df)

# I clean and replace all NAs if present.

comp_table_final <- comp_table
comp_table_final[is.na(comp_table_final <- comp_table)] <- 0
comp_table_final = unique(comp_table_final)
fwrite(comp_table_final,"./results/comp_table_final.txt",col.names=T,row.names=F,sep="\t",quote=F)
system("gzip ./results/comp_table_final.txt --force")
unlink("./results/comp_table_final.txt")
```

The comparison set gives a total number of `r nrow(comp_table_final)` potentially interacting pairs, of which `r nrow(comp_table_final[comp_table_final$imex==0,])` (`r round(nrow(comp_table_final[comp_table_final$imex==0,])*100/nrow(comp_table_final),2)`%) are not curated in IMEx. 

Overlaps at the pair level, summary:
========================================================
```{r visualize_overlaps, fig.height=9, fig.width=12, results='hide'}
groups = colnames(comp_table_final)[2:ncol(comp_table_final)]
# generate expression like this "comp_table_final[, overlaps := paste0(imex,reactome,tm_epmc,iid_pred,EVEX,BioGRID,GO_IPI,OmniPath)]" and evaluate it - this way the code is independent of column names
eval(parse(text=paste0("comp_table_final[, overlaps := paste0(",paste0(groups, collapse= ","),")]")))
eval(parse(text=paste0("comp_table_final[, N_overlaps := sum(",paste0(groups, collapse= ","),"), by = pair_id]")))

comp_table_final[, N_per_overlaps := .N, by = overlaps]
comp_table_final[, N_per_N_overlaps := .N, by = N_overlaps]

N_overlaps = unique(comp_table_final[,.(N_overlaps, N_per_N_overlaps)])
N_overlaps = N_overlaps[order(N_per_N_overlaps, decreasing = T),]
qplot(label = N_overlaps$N_per_N_overlaps, y = N_overlaps$N_per_N_overlaps, x = N_overlaps$N_overlaps,  geom = "text") + scale_y_log10(labels = 10^c(1:7), breaks = 10^c(1:7)) +
        ggtitle("The number of interacting pairs and the number of resources \n the pairs are shared between") + ylab("the number of interacting pairs, log10 scale")+ xlab("the number of resources")+scale_x_continuous(labels = N_overlaps$N_overlaps, breaks = N_overlaps$N_overlaps)+theme(text = element_text(size =15), title = element_text(size =24))

overlaps = unique(comp_table_final[,.(overlaps, N_per_overlaps)])
overlaps = overlaps[order(N_per_overlaps, decreasing = T),]
```


Part 2: Generating comparison dataset at the publication level
========================================================

```{r, eval=T, results='hide'}
allpub_df <- list(imex_pmids,reactome_pmids,tm_pmids, EVEX_pmids, BioGRID_pmids, GO_IPI_pmids, OmniPath_pmids)

pubcomp_table <- Reduce(function(...) merge(..., all=TRUE), allpub_df)

# I clean and replace all NAs if present.

pubcomp_table_final <- pubcomp_table
pubcomp_table_final[is.na(pubcomp_table_final <- pubcomp_table)] <- 0
fwrite(pubcomp_table_final,"./results/pubcomp_table_final.txt",col.names=T,row.names=F,sep="\t",quote=F)
system("gzip ./results/pubcomp_table_final.txt --force")
```

The comparison set gives a total number of `r nrow(pubcomp_table_final)` publications, of which `r nrow(pubcomp_table_final[pubcomp_table_final$imex==0,])` (`r round(nrow(pubcomp_table_final[pubcomp_table_final$imex==0,])*100/nrow(pubcomp_table_final),2)`%) are not curated in IMEx. 

Overlaps at the publication level, summary:
========================================================
```{r visualize_overlaps_publications, fig.height=9, fig.width=12, results='hide'}
pubgroups = colnames(pubcomp_table_final)[2:ncol(pubcomp_table_final)]
pubcomp_table_final[, puboverlaps := paste0(imex, reactome, tm_epmc, EVEX, BioGRID, GO_IPI, OmniPath)]
pubcomp_table_final[, N_puboverlaps := sum(imex, reactome, tm_epmc, EVEX, BioGRID, GO_IPI, OmniPath), by = pmid]
pubcomp_table_final[, N_per_puboverlaps := .N, by = puboverlaps]
pubcomp_table_final[, N_per_N_puboverlaps := .N, by = N_puboverlaps]

N_puboverlaps = unique(pubcomp_table_final[,.(N_puboverlaps, N_per_N_puboverlaps)])
N_puboverlaps = N_puboverlaps[order(N_per_N_puboverlaps, decreasing = T),]
qplot(label = N_puboverlaps$N_per_N_puboverlaps, y = N_puboverlaps$N_per_N_puboverlaps, x = N_puboverlaps$N_puboverlaps,  geom = "text") + scale_y_log10(labels = 10^c(1:7), breaks = 10^c(1:7)) +
        ggtitle("The number of publications and the number of resources \n the publications are shared between") + ylab("the number of publications, log10 scale")+ xlab("the number of resources")+scale_x_continuous(labels = N_puboverlaps$N_puboverlaps, breaks = N_puboverlaps$N_puboverlaps)+theme(text = element_text(size =15), title = element_text(size =24))
```

Part 3: Generating comparison dataset at the pair level taking the publication into account
========================================================

```{r, eval=T, results='hide'}
prepubpaircomp_table_1 <- unique(merge(imex_human_sel,reactome_pairs_pmids,by=c("pair_id","pmid"),all=T))
prepubpaircomp_table_1 <- unique(merge(prepubpaircomp_table_1,tm_pairs_pmids_sel,by=c("pair_id","pmid"),all=T))
prepubpaircomp_table_1 <- unique(merge(prepubpaircomp_table_1,EVEX_pairs_pmids_sel,by=c("pair_id","pmid"),all=T))
prepubpaircomp_table_1 <- unique(merge(prepubpaircomp_table_1,BioGRID_pairs_pmids_sel,by=c("pair_id","pmid"),all=T))
prepubpaircomp_table_1 <- unique(merge(prepubpaircomp_table_1,GO_IPI_pairs_pmids_sel,by=c("pair_id","pmid"),all=T))
prepubpaircomp_table_1 <- unique(merge(prepubpaircomp_table_1,OmniPath_pairs_pmids_sel,by=c("pair_id","pmid"),all=T))

pubpaircomp_table <- unique(merge(prepubpaircomp_table_1,iid_pred_pairs,by=c("pair_id"),all=T))

# I clean and replace all NAs if present.

pubpaircomp_table_form <- pubpaircomp_table
pubpaircomp_table_form[is.na(pubpaircomp_table_form)] <- 0
```

The comparison set gives a total number of `r nrow(pubpaircomp_table_form)` protein association pairs, of which `r nrow(pubpaircomp_table_form[pubpaircomp_table_form$imex==0,])` (`r round(nrow(pubpaircomp_table_form[pubpaircomp_table_form$imex==0,])*100/nrow(pubpaircomp_table_form),2)`%) are not curated in IMEx. In all these pairs the publication from which they were derived was also matched, so the overlaps and numbers differ from previous comparisons. 

Part 4: Comparing groups of resources
========================================================
type: section

1 Pathways
========================================================
type: sub-section

Reactome vs Omnipath (excluding IMEx databases, BioGRID, HPRD, STRING) vs STRING pathway-based inference
========================================================

```{r Pathways_1, fig.width = 16, fig.height= 6}

grid.newpage()
plotname = paste0("Comparison of pathway resources: Reactome, Omnipath, STRING pathway-based inference")
# setup grid
pushViewport(viewport(layout=grid.layout(nrow = 3, ncol=5, widths = unit(c(1/14,4/14,4/14,4/14,1/14), "npc"), 
                                         heights = unit(c(1/7, 1/7, 5/7), "npc"))))
# plot names
pushViewport(viewport(layout.pos.col=2, layout.pos.row = 1))
x =grid.text(plotname, x = unit(1.6, "npc"),y= unit(0.5, "npc"), gp=gpar(fontsize=20))
popViewport()

# individual labels
pushViewport(viewport(layout.pos.col=2, layout.pos.row = 2))
x =grid.text("interacting pairs", x = unit(0.5, "npc"),y= unit(0.5, "npc"), gp=gpar(fontsize=20))
popViewport()

pushViewport(viewport(layout.pos.col=3, layout.pos.row = 2))
x =grid.text("publications", x = unit(0.5, "npc"),y= unit(0.5, "npc"), gp=gpar(fontsize=20))
popViewport()

pushViewport(viewport(layout.pos.col=4, layout.pos.row = 2))
x =grid.text("interacting pairs and publications", x = unit(0.5, "npc"),y= unit(0.5, "npc"), gp=gpar(fontsize=20))
popViewport()

# venn diagrams
pushViewport(viewport(layout.pos.col=2, layout.pos.row = 3))

Pathways_1 = unique(comp_table_final[,.(pair_id, reactome, OmniPath, STRING_pathway_inference)])
venn_Pathways_1 = draw.triple.venn(area1 = Pathways_1[reactome == 1,.N], 
                          area2 = Pathways_1[OmniPath == 1,.N], 
                          area3 = Pathways_1[STRING_pathway_inference == 1,.N], 
                          n12 = Pathways_1[reactome == 1 & OmniPath == 1,.N], 
                          n23 = Pathways_1[OmniPath == 1 & STRING_pathway_inference == 1,.N],
                          n13 = Pathways_1[reactome == 1 & STRING_pathway_inference == 1,.N],
                          n123 = Pathways_1[reactome == 1 & OmniPath == 1 & STRING_pathway_inference == 1,.N], 
                          category = c("Reactome", 
                                       "OmniPath", 
                                       "STRING_pathway_inference"), 
                          lty = rep("blank", 3), 
                          fill = c("blue", "red", "green"), 
                          alpha = rep(0.5, 3), cat.pos = c(350, 25, 160), 
                          cat.dist = c(0.08,0.035, 0.08), 
                          cat.cex = c(1.4,1.4, 1.4), scaled = TRUE, euler.d = TRUE,  margin = 0.05,
                          print.mode =  'raw',
                          cex = 1.5
)
popViewport()

pushViewport(viewport(layout.pos.col=3, layout.pos.row = 3))
Pathways_2 = unique(pubcomp_table_final[,.(pmid, reactome, OmniPath)])
venn_Pathways_2 = draw.pairwise.venn(area1 = Pathways_2[reactome == 1,.N], 
                          area2 = Pathways_2[OmniPath == 1,.N], 
                          cross.area = Pathways_2[reactome == 1 & OmniPath == 1,.N], 
                          category = c("Reactome", 
                                       "OmniPath"), 
                          lty = rep("blank", 2), 
                          fill = c("blue", "red"), 
                          alpha = rep(0.5, 2), cat.pos = c(350, 25), 
                          cat.dist = c(0.08,0.035), 
                          cat.cex = c(1.4,1.4), scaled = TRUE, euler.d = TRUE,  margin = 0.05,
                          print.mode =  'raw',
                          cex = 1.5
)
popViewport()

pushViewport(viewport(layout.pos.col=4, layout.pos.row = 3))
Pathways_3 = unique(pubpaircomp_table_form[,.(pair_id, pmid, reactome, OmniPath)])
venn_Pathways_3 = draw.pairwise.venn(area1 = Pathways_3[reactome == 1,.N], 
                          area2 = Pathways_3[OmniPath == 1,.N], 
                          cross.area = Pathways_3[reactome == 1 & OmniPath == 1,.N], 
                          category = c("Reactome", 
                                       "OmniPath"), 
                          lty = rep("blank", 2), 
                          fill = c("blue", "red"), 
                          alpha = rep(0.5, 2), cat.pos = c(350, 25), 
                          cat.dist = c(0.08,0.035), 
                          cat.cex = c(1.4,1.4), scaled = TRUE, euler.d = TRUE,  margin = 0.05,
                          print.mode =  'raw',
                          cex = 1.5
)
popViewport()

```

2 Text-mining
========================================================
type: sub-section

EPMC-TM vs EVEX vs STRING textmining
========================================================
```{r tm_1, fig.width = 16, fig.height= 6}
{ 
grid.newpage()
plotname = paste0("Comparison of text-mining (NLP?) resources: EVEX and custom EPMC text-mining datasets")
# setup grid
pushViewport(viewport(layout=grid.layout(nrow = 3, ncol=5, widths = unit(c(1/14,4/14,4/14,4/14,1/14), "npc"), 
                                         heights = unit(c(1/7, 1/7, 5/7), "npc"))))
# plot names
pushViewport(viewport(layout.pos.col=2, layout.pos.row = 1))
x =grid.text(plotname, x = unit(1.3, "npc"),y= unit(0.5, "npc"), gp=gpar(fontsize=20))
popViewport()

# individual labels
pushViewport(viewport(layout.pos.col=2, layout.pos.row = 2))
x =grid.text("interacting pairs", x = unit(0.5, "npc"),y= unit(0.5, "npc"), gp=gpar(fontsize=20))
popViewport()

pushViewport(viewport(layout.pos.col=3, layout.pos.row = 2))
x =grid.text("publications", x = unit(0.5, "npc"),y= unit(0.5, "npc"), gp=gpar(fontsize=20))
popViewport()

pushViewport(viewport(layout.pos.col=4, layout.pos.row = 2))
x =grid.text("interacting pairs and publications", x = unit(0.5, "npc"),y= unit(0.5, "npc"), gp=gpar(fontsize=20))
popViewport()

# venn diagrams
pushViewport(viewport(layout.pos.col=2, layout.pos.row = 3))
textmining_1 = unique(comp_table_final[,.(pair_id, tm_epmc, EVEX, STRING_textmining)])
venn_Interactions_1 = draw.triple.venn(area1 = textmining_1[tm_epmc == 1,.N], 
                          area2 = textmining_1[EVEX == 1,.N], 
                          area3 = textmining_1[STRING_textmining == 1,.N], 
                          n12 = textmining_1[tm_epmc == 1 & EVEX == 1,.N], 
                          n23 = textmining_1[EVEX == 1 & STRING_textmining == 1,.N],
                          n13 = textmining_1[tm_epmc == 1 & STRING_textmining == 1,.N],
                          n123 = textmining_1[tm_epmc == 1 & EVEX == 1 & STRING_textmining == 1,.N], 
                          category = c("EPMC text-mining", 
                                       "EVEX", 
                                       "STRING_textmining"), 
                          lty = rep("blank", 3), 
                          fill = c("blue", "red", "green"), 
                          alpha = rep(0.5, 3), cat.pos = c(350, 25, 160), 
                          cat.dist = c(0.08,0.035, 0.08), 
                          cat.cex = c(1.4,1.4, 1.4), scaled = TRUE, euler.d = TRUE,  margin = 0.05,
                          print.mode =  'raw',
                          cex = 1.5
)
popViewport()

pushViewport(viewport(layout.pos.col=3, layout.pos.row = 3))
textmining_2 = unique(pubcomp_table_final[,.(pmid, tm_epmc, EVEX)])
venn_Pathways_2 = draw.pairwise.venn(area1 = textmining_2[tm_epmc == 1,.N], 
                          area2 = textmining_2[EVEX == 1,.N], 
                          cross.area = textmining_2[tm_epmc == 1 & EVEX == 1,.N], 
                          category = c("EPMC text-mining", 
                                       "EVEX"), 
                          lty = rep("blank", 2), 
                          fill = c("blue", "red"), 
                          alpha = rep(0.5, 2), cat.pos = c(350, 25), 
                          cat.dist = c(0.08,0.035), 
                          cat.cex = c(1.4,1.4), scaled = TRUE, euler.d = TRUE,  margin = 0.05,
                          print.mode =  'raw',
                          cex = 1.5
)
popViewport()

pushViewport(viewport(layout.pos.col=4, layout.pos.row = 3))
textmining_3 = unique(pubpaircomp_table_form[,.(pair_id, pmid, tm_epmc, EVEX)])
venn_Pathways_3 = draw.pairwise.venn(area1 = textmining_3[tm_epmc == 1,.N], 
                          area2 = textmining_3[EVEX == 1,.N], 
                          cross.area = textmining_3[tm_epmc == 1 & EVEX == 1,.N], 
                          category = c("EPMC text-mining", 
                                       "EVEX"), 
                          lty = rep("blank", 2), 
                          fill = c("blue", "red"), 
                          alpha = rep(0.5, 2), cat.pos = c(350, 25), 
                          cat.dist = c(0.08,0.035), 
                          cat.cex = c(1.4,1.4), scaled = TRUE, euler.d = TRUE,  margin = 0.05,
                          print.mode =  'raw',
                          cex = 1.5
)
popViewport()
}
```

3 Predictions
========================================================
type: sub-section

IID vs STRING phylogeny- and orthology-based predictions 
========================================================

```{r Predictions_1,  fig.width = 16, fig.height= 6}
{ 
grid.newpage()
plotname = paste0("Comparison of predictions resources: IID and STRING phylogeny-/orthology-based predictions")
# setup grid
pushViewport(viewport(layout=grid.layout(nrow = 3, ncol=3, widths = unit(c(3/14,8/14,3/14), "npc"), 
                                         heights = unit(c(1/7, 1/7, 5/7), "npc"))))
# plot names
pushViewport(viewport(layout.pos.col=2, layout.pos.row = 1))
x =grid.text(plotname, x = unit(0.3, "npc"),y= unit(0.5, "npc"), gp=gpar(fontsize=20))
popViewport()

# individual labels
pushViewport(viewport(layout.pos.col=2, layout.pos.row = 2))
x =grid.text("interacting pairs", x = unit(0.5, "npc"),y= unit(0.5, "npc"), gp=gpar(fontsize=20))
popViewport()

# venn diagrams
pushViewport(viewport(layout.pos.col=2, layout.pos.row = 3))
Predictions_1 = unique(comp_table_final[,.(pair_id, iid_pred, STRING_phylo_predictions)])
venn_Pathways_2 = draw.pairwise.venn(area1 = Predictions_1[iid_pred == 1,.N], 
                          area2 = Predictions_1[STRING_phylo_predictions == 1,.N], 
                          cross.area = Predictions_1[iid_pred == 1 & STRING_phylo_predictions == 1,.N], 
                          category = c("IID predictions", 
                                       "STRING predictions"), 
                          lty = rep("blank", 2), 
                          fill = c("blue", "red"), 
                          alpha = rep(0.5, 2), cat.pos = c(350, 25), 
                          cat.dist = c(0.08,0.035), 
                          cat.cex = c(1.4,1.4), scaled = TRUE, euler.d = TRUE,  margin = 0.05,
                          print.mode =  'raw',
                          cex = 1.5
)
popViewport()
}
```

4 Interactions
========================================================
type: sub-section

IMEx vs Biogrid vs GO IPI
========================================================

```{r Interactions_1, fig.width = 16, fig.height= 6}

{
grid.newpage()
plotname = paste0("Comparison of interaction resources: IMEx, Biogrid, GO IPI")
# setup grid
pushViewport(viewport(layout=grid.layout(nrow = 3, ncol=5, widths = unit(c(1/14,4/14,4/14,4/14,1/14), "npc"), 
                                         heights = unit(c(1/7, 1/7, 5/7), "npc"))))
# plot names
pushViewport(viewport(layout.pos.col=2, layout.pos.row = 1))
x =grid.text(plotname, x = unit(0.7, "npc"),y= unit(0.5, "npc"), gp=gpar(fontsize=20))
popViewport()

# individual labels
pushViewport(viewport(layout.pos.col=2, layout.pos.row = 2))
x =grid.text("interacting pairs", x = unit(0.5, "npc"),y= unit(0.5, "npc"), gp=gpar(fontsize=20))
popViewport()

pushViewport(viewport(layout.pos.col=3, layout.pos.row = 2))
x =grid.text("publications", x = unit(0.5, "npc"),y= unit(0.5, "npc"), gp=gpar(fontsize=20))
popViewport()

pushViewport(viewport(layout.pos.col=4, layout.pos.row = 2))
x =grid.text("interacting pairs and publications", x = unit(0.5, "npc"),y= unit(0.5, "npc"), gp=gpar(fontsize=20))
popViewport()

# venn diagrams
pushViewport(viewport(layout.pos.col=2, layout.pos.row = 3))
Interactions_1 = unique(comp_table_final[,.(pair_id, imex, BioGRID, GO_IPI)])
N_Interactions_1 = nrow(Interactions_1)
venn_Interactions_1 = draw.triple.venn(area1 = Interactions_1[imex == 1,.N], 
                          area2 = Interactions_1[BioGRID == 1,.N], 
                          area3 = Interactions_1[GO_IPI == 1,.N], 
                          n12 = Interactions_1[imex == 1 & BioGRID == 1,.N], 
                          n23 = Interactions_1[BioGRID == 1 & GO_IPI == 1,.N],
                          n13 = Interactions_1[imex == 1 & GO_IPI == 1,.N],
                          n123 = Interactions_1[imex == 1 & BioGRID == 1 & GO_IPI == 1,.N], 
                          category = c("IMEx", 
                                       "BioGRID", 
                                       "GO_IPI"), 
                          lty = rep("blank", 3), 
                          fill = c("blue", "red", "green"), 
                          alpha = rep(0.5, 3), cat.pos = c(350, 25, 160), 
                          cat.dist = c(0.08,0.035, 0.08), 
                          cat.cex = c(1.4,1.4, 1.4), scaled = TRUE, euler.d = TRUE,  margin = 0.05,
                          print.mode =  'raw',
                          cex = 1.5
)
popViewport()

pushViewport(viewport(layout.pos.col=3, layout.pos.row = 3))
Interactions_2 = unique(pubcomp_table_final[,.(pmid, imex, BioGRID, GO_IPI)])
N_Interactions_2 = nrow(Interactions_2)
venn_Interactions_2 = draw.triple.venn(area1 = Interactions_2[imex == 1,.N], 
                          area2 = Interactions_2[BioGRID == 1,.N], 
                          area3 = Interactions_2[GO_IPI == 1,.N], 
                          n12 = Interactions_2[imex == 1 & BioGRID == 1,.N], 
                          n23 = Interactions_2[BioGRID == 1 & GO_IPI == 1,.N],
                          n13 = Interactions_2[imex == 1 & GO_IPI == 1,.N],
                          n123 = Interactions_2[imex == 1 & BioGRID == 1 & GO_IPI == 1,.N], 
                          category = c("IMEx", 
                                       "BioGRID", 
                                       "GO_IPI"), 
                          lty = rep("blank", 3), 
                          fill = c("blue", "red", "green"), 
                          alpha = rep(0.5, 3), cat.pos = c(350, 25, 160), 
                          cat.dist = c(0.08,0.035, 0.08), 
                          cat.cex = c(1.4,1.4, 1.4), scaled = TRUE, euler.d = TRUE,  margin = 0.05,
                          print.mode =  'raw',
                          cex = 1.5
)
popViewport()

pushViewport(viewport(layout.pos.col=4, layout.pos.row = 3))
Interactions_3 = unique(pubpaircomp_table_form[,.(pair_id, pmid, imex, BioGRID, GO_IPI)])
N_Interactions_3 = nrow(Interactions_3)
venn_Interactions_3 = draw.triple.venn(area1 = Interactions_3[imex == 1,.N], 
                          area2 = Interactions_3[BioGRID == 1,.N], 
                          area3 = Interactions_3[GO_IPI == 1,.N], 
                          n12 = Interactions_3[imex == 1 & BioGRID == 1,.N], 
                          n23 = Interactions_3[BioGRID == 1 & GO_IPI == 1,.N],
                          n13 = Interactions_3[imex == 1 & GO_IPI == 1,.N],
                          n123 = Interactions_3[imex == 1 & BioGRID == 1 & GO_IPI == 1,.N], 
                          category = c("IMEx", 
                                       "BioGRID", 
                                       "GO_IPI"), 
                          lty = rep("blank", 3), 
                          fill = c("blue", "red", "green"), 
                          alpha = rep(0.5, 3), cat.pos = c(350, 25, 160), 
                          cat.dist = c(0.08,0.035, 0.08), 
                          cat.cex = c(1.4,1.4, 1.4), scaled = TRUE, euler.d = TRUE,  margin = 0.05,
                          print.mode =  'raw',
                          cex = 1.5
)
popViewport()
}
```


which resources are enriched in the publications containing interaction data?
========================================================
type: section


========================================================
type: sub-section
## 1 Are particular resources enriched in the IMEx-curated publications ?

```{r GeneID_to_publication_IDs, results='hide'}
## getting the publication ID for each gene
{
geneID2pubmed_url = "ftp://ftp.ncbi.nih.gov/gene/DATA/gene2pubmed.gz"
geneID2pubmed_filename = paste0("./geneID2pubmed_release_", format(Sys.Date(), "%m-%Y.gz"))
geneID2pubmed_filename_txt = substr(geneID2pubmed_filename, 1, nchar(geneID2pubmed_filename)-3)
if(!file.exists(geneID2pubmed_filename_txt)) {
  downloader::download(geneID2pubmed_url, geneID2pubmed_filename)
  R.utils::gunzip(geneID2pubmed_filename)
  gitignore = c(readLines("../.gitignore"), paste0("/dsp_comparison/geneID2pubmed_release_", format(Sys.Date(), "%m-%Y")))
  write(gitignore,"../.gitignore")
}
}

# getting all pmids which have genes associated with them
geneID2pubmed = fread(geneID2pubmed_filename_txt, colClasses = c("character","character","character"))
pubmedIDs = geneID2pubmed[`#tax_id` == "9606",unique(PubMed_ID)]
```

As compared to NCBI gene to pubmed ID dataset (hypergeometric test, p-values):
```{r}
# enrichment of resources in imex-curated publications
# all gene-assiciated pmids
total_Npmids = length(pubmedIDs)
imex_Npmids = length(pubcomp_table_final[imex == 1,unique(pmid)])
# counting pmids in each of the resources
resources = colnames(pubcomp_table_final)[2:8]
resources_Npmids = sapply(resources, function(x) eval(parse(text=paste0("length(pubcomp_table_final[",x," == 1,unique(pmid)])"))))
# how many pmids overlap with IMEx
resources_Npmids_in_IMEx = sapply(resources, function(x) eval(parse(text=paste0("length(pubcomp_table_final[imex == 1 & ",x," == 1,unique(pmid)])"))))
resources_Npmids2 = rbind(resources_Npmids, resources_Npmids_in_IMEx)
# hypergeometric test
apply(resources_Npmids2,2, function(x){
                phyper(q = x[2], m = imex_Npmids, n = total_Npmids - imex_Npmids, k = x[1], lower.tail = F, log.p = FALSE)
})
```

========================================================
type: sub-section
As compared to the union of all resources in this comparison (hypergeometric test, p-values):
```{r}
# all pmids in our resources
total_Npmids_our = length(pubcomp_table_final[,unique(pmid)])
# hypergeometric test
apply(resources_Npmids2,2, function(x){
                phyper(q = x[2], m = imex_Npmids, n = total_Npmids_our - imex_Npmids, k = x[1], lower.tail = F, log.p = FALSE)
})
```


========================================================
type: sub-section
## 2 Are particular resources enriched in the BioGRID-curated publications ?

As compared to NCBI gene to pubmed ID dataset (hypergeometric test, p-values):
```{r}
BioGRID_Npmids = length(pubcomp_table_final[BioGRID == 1,unique(pmid)])
resources_Npmids_in_BioGRID = sapply(resources, function(x) eval(parse(text=paste0("length(pubcomp_table_final[BioGRID == 1 & ",x," == 1,unique(pmid)])"))))
resources_Npmids2 = rbind(resources_Npmids, resources_Npmids_in_BioGRID)
apply(resources_Npmids2,2, function(x){
                phyper(q = x[2], m = BioGRID_Npmids, n = total_Npmids - BioGRID_Npmids, k = x[1], lower.tail = F, log.p = FALSE)
})
```


========================================================
type: sub-section
## 3 Fractions: IMEx-curated publications

```{r, fig.width = 12, fig.height= 6}
# enrichment of resources in imex-curated publications
# all gene-assiciated pmids
total_Npmids = length(pubmedIDs)
imex_Npmids = length(pubcomp_table_final[imex == 1,unique(pmid)])
# counting pmids in each of the resources
resources = colnames(pubcomp_table_final)[2:8]
resources_Npmids = sapply(resources, function(x) eval(parse(text=paste0("length(pubcomp_table_final[",x," == 1,unique(pmid)])"))))
# how many pmids overlap with IMEx
resources_Npmids_in_IMEx = sapply(resources, function(x) eval(parse(text=paste0("length(pubcomp_table_final[imex == 1 & ",x," == 1,unique(pmid)])"))))
resources_Npmids2 = rbind(resources_Npmids, resources_Npmids_in_IMEx)
resources_Npmids2 = cbind(resources_Npmids2, gene2pubmed = c(total_Npmids, imex_Npmids))
resources_Npmids2 = rbind(resources_Npmids2, fraction = c(resources_Npmids2[2,]/resources_Npmids2[1,]))

qplot(x = colnames(resources_Npmids2), y =resources_Npmids2[3,], geom = "point", ylab = "fraction of papers in IMEx", xlab = NULL) + scale_y_continuous(breaks = seq(0,1.2,0.05))+theme(text = element_text(size = 17),axis.text.x = element_text(angle =-25, vjust = 0.6, size = 17))+geom_text(label = paste0(signif(resources_Npmids2[2,],3)," /\n",signif(resources_Npmids2[1,],3)), vjust = -0.5)+geom_text(label = signif(resources_Npmids2[3,],3), vjust = 1.4)
```


========================================================
type: sub-section
## 4 Fractions: BioGRID-curated publications
```{r, fig.width = 12, fig.height= 6}
# enrichment of resources in BioGRID-curated publications
# all gene-assiciated pmids
total_Npmids = length(pubmedIDs)
BioGRID_Npmids = length(pubcomp_table_final[BioGRID == 1,unique(pmid)])
# counting pmids in each of the resources
resources = colnames(pubcomp_table_final)[2:8]
resources_Npmids = sapply(resources, function(x) eval(parse(text=paste0("length(pubcomp_table_final[",x," == 1,unique(pmid)])"))))
# how many pmids overlap with BioGRID
resources_Npmids_in_BioGRID = sapply(resources, function(x) eval(parse(text=paste0("length(pubcomp_table_final[BioGRID == 1 & ",x," == 1,unique(pmid)])"))))
resources_Npmids2 = rbind(resources_Npmids, resources_Npmids_in_BioGRID)
resources_Npmids2 = cbind(resources_Npmids2, gene2pubmed = c(total_Npmids, BioGRID_Npmids))
resources_Npmids2 = rbind(resources_Npmids2, fraction = c(resources_Npmids2[2,]/resources_Npmids2[1,]))

qplot(x = colnames(resources_Npmids2), y =resources_Npmids2[3,], geom = "point", ylab = "fraction of papers in BioGRID", xlab = NULL) + scale_y_continuous(breaks = seq(0,1,0.05))+theme(text = element_text(size = 17),axis.text.x = element_text(angle =-25, vjust = 0.6, size = 17))+geom_text(label = paste0(signif(resources_Npmids2[2,],3)," /\n",signif(resources_Npmids2[1,],3)), vjust = -0.5)+geom_text(label = signif(resources_Npmids2[3,],3), vjust = 1.4)
```


========================================================
type: sub-section
## tm_epmc (old) is depleted in interaction-containing papers as compared to all gene-associated (NCBI) papers!

========================================================
type: sub-section
## 5 Fractions: IMEx-curated interacting pairs

```{r, fig.width = 12, fig.height= 6}
# enrichment of resources in imex-curated interacting pairs
imex_Npmids = length(comp_table_final[imex == 1,unique(pair_id)])
# counting pmids in each of the resources
resources = colnames(comp_table_final)[2:12]
resources_Npmids = sapply(resources, function(x) eval(parse(text=paste0("length(comp_table_final[",x," == 1,unique(pair_id)])"))))
# how many pmids overlap with IMEx
resources_Npmids_in_IMEx = sapply(resources, function(x) eval(parse(text=paste0("length(comp_table_final[imex == 1 & ",x," == 1,unique(pair_id)])"))))
resources_Npmids2 = rbind(resources_Npmids, resources_Npmids_in_IMEx)
resources_Npmids2 = rbind(resources_Npmids2, fraction = c(resources_Npmids2[2,]/resources_Npmids2[1,]))

qplot(x = colnames(resources_Npmids2), y =resources_Npmids2[3,], geom = "point", ylab = "fraction of interacting pairs in IMEx", xlab = NULL) + scale_y_continuous(breaks = seq(0,1,0.05))+theme(text = element_text(size = 17),axis.text.x = element_text(angle =-25, vjust = 0.6, size = 17))+geom_text(label = paste0(signif(resources_Npmids2[2,],3)," /\n",signif(resources_Npmids2[1,],3)), vjust = -0.5)+geom_text(label = signif(resources_Npmids2[3,],3), vjust = 1.4)
```

========================================================
type: sub-section
## 6 Fractions: BioGRID-curated interacting pairs

```{r, fig.width = 12, fig.height= 6}
# enrichment of resources in BioGRID-curated publications
# all gene-assiciated pmids
total_Npmids = length(pubmedIDs)
BioGRID_Npmids = length(comp_table_final[BioGRID == 1,unique(pair_id)])
# counting pmids in each of the resources
resources = colnames(comp_table_final)[2:12]
resources_Npmids = sapply(resources, function(x) eval(parse(text=paste0("length(comp_table_final[",x," == 1,unique(pair_id)])"))))
# how many pmids overlap with BioGRID
resources_Npmids_in_BioGRID = sapply(resources, function(x) eval(parse(text=paste0("length(comp_table_final[BioGRID == 1 & ",x," == 1,unique(pair_id)])"))))
resources_Npmids2 = rbind(resources_Npmids, resources_Npmids_in_BioGRID)
# resources_Npmids2 = cbind(resources_Npmids2, gene2pubmed = c(total_Npmids, imex_Npmids))
resources_Npmids2 = rbind(resources_Npmids2, fraction = c(resources_Npmids2[2,]/resources_Npmids2[1,]))

qplot(x = colnames(resources_Npmids2), y =resources_Npmids2[3,], geom = "point", ylab = "fraction of interacting pairs in BioGRID", xlab = NULL) + scale_y_continuous(breaks = seq(0,1,0.05))+theme(text = element_text(size = 17),axis.text.x = element_text(angle =-25, vjust = 0.6, size = 17))+geom_text(label = paste0(signif(resources_Npmids2[2,],3)," /\n",signif(resources_Npmids2[1,],3)), vjust = -0.5)+geom_text(label = signif(resources_Npmids2[3,],3), vjust = 1.4)
```

========================================================
type: sub-section
## groups of resources enriched in curated interaction data (IMEx+BioGRID+GO IPI)

```{r, fig.width = 12, fig.height= 6}
Interactions_ids = Interactions_1[imex == 1 | BioGRID == 1 | GO_IPI == 1, unique(pair_id)]
Pathways_ids = Pathways_1[reactome == 1 | OmniPath == 1 | STRING_pathway_inference == 1, unique(pair_id)]
textmining_ids = textmining_1[tm_epmc == 1 | EVEX == 1 | STRING_textmining == 1, unique(pair_id)]
Predictions_ids = Predictions_1[iid_pred == 1 | STRING_phylo_predictions == 1, unique(pair_id)]


area1 = length(Interactions_ids)
area2 = length(Pathways_ids)
area3 = length(textmining_ids)
area4 = length(Predictions_ids)
n12 = sum(!is.na(match(Interactions_ids, Pathways_ids)))
n13 = sum(!is.na(match(Interactions_ids, textmining_ids)))
n14 = sum(!is.na(match(Interactions_ids, Predictions_ids)))
n23 = sum(!is.na(match(Pathways_ids, textmining_ids)))
n24 = sum(!is.na(match(Pathways_ids, Predictions_ids)))
n34 = sum(!is.na(match(textmining_ids, Predictions_ids)))
n123 = length(intersect(intersect((Interactions_ids),(Pathways_ids)),(textmining_ids)))
n124 = length(intersect(intersect((Interactions_ids),(Pathways_ids)),(Predictions_ids)))
n134 = length(intersect(intersect((Interactions_ids),(textmining_ids)),(Predictions_ids)))
n234 = length(intersect(intersect((Pathways_ids),(textmining_ids)),(Predictions_ids)))
n1234 = length(intersect(intersect(intersect((Interactions_ids),(Pathways_ids)),(textmining_ids)), (Predictions_ids)))


venn_Interactions_1 = draw.quad.venn(area1, area2, area3, area4, n12, n13, n14, n23, n24,
    n34, n123, n124, n134, n234, n1234, 
                          category = c("Interactions", 
                                       "Pathways", 
                                       "Textmining",
                                       "Predictions"), 
                          lty = rep("blank", 4), 
                          fill = c("blue", "red", "green", "grey"), 
                          alpha = rep(0.5, 4), cat.pos = c(350, 25, 160,45), 
                          cat.dist = c(0.08,0.035, -0.08, 0.08), 
                          cat.cex = c(1.4,1.4, 1.4, 1.4), scaled = TRUE, euler.d = TRUE,  margin = 0.05,
                          print.mode =  'raw',
                          cex = 1.5
)
```

========================================================
type: sub-section
## groups of resources enriched in curated interaction data (IMEx+BioGRID+GO IPI)

```{r, fig.width = 12, fig.height= 6}
qplot(x = c("Interactions","Pathways","Textmining","Predictions", "Pathways & Textmining", "Pathways & Predictions", "Textmining & Predictions", "Pathways & Textmining & Predictions"), y = c(area1/area1, n12/area2, n13/area3, n14/area4, n123/n23, n124/n24, n134/n34, n1234/n234), geom = "point", ylab = "fraction of interacting pairs in IMEx", xlab = NULL) + scale_y_continuous(breaks = seq(0,1,0.1))+theme(text = element_text(size = 17),axis.text.x = element_text(angle =-25, vjust = 0.6, size = 17))+
        geom_text(label = c("", 
                            paste0(signif(n12,3)," /\n",signif(area2,3)), 
                            paste0(signif(n13,3)," /\n",signif(area3,3)), 
                            paste0(signif(n14,3)," /\n",signif(area4,3)),
                            paste0(signif(n123,3)," /\n",signif(n23,3)),
                            paste0(signif(n124,3)," /\n",signif(n24,3)),
                            paste0(signif(n134,3)," /\n",signif(n34,3)),
                            paste0(signif(n1234,3)," /\n",signif(n234,3))), vjust = -0.5)+
        geom_text(label = signif(c(area1/area1, n12/area2, n13/area3, n14/area4, n123/n23, n124/n24, n134/n34, n1234/n234),3), vjust = 1.4)
```