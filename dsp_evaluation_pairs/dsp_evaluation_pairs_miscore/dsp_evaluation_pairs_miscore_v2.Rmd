---
title: "DSP evaluation pairs MIscore"
author: "Pablo Porras"
date: "14/02/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Evaluation of checked and curated publications of the DSP

I manually download all DSP evaluated PMIDs and also those already curated and avaliable on the IntAct website. 

##### Libraries
```{r libraries, message=FALSE,warning=FALSE}
library(data.table)
library(splitstackshape)
library(stringr)
library(ggplot2)
library(scales)
library(dplyr)
library(ggsignif)
library(UniProt.ws)
library(readxl)
```

#### Data upload
```{r upload}
# These come from the Google spreadsheet, manually downloaded. 
eval_dsp <- fread("./source_data/20190214_dsp_priority_rev_pred.tsv",
                  header = T,
                  colClasses = "character",
                  stringsAsFactors = F,
                  check.names = T,
                  sep = "\t")

if (!file.exists("./source_data/intact.zip")){
        download.file(url="ftp://ftp.ebi.ac.uk/pub/databases/intact/current/psimitab/intact.zip",destfile = "./source_data/intact.zip",method = "curl")
}

if (!file.exists("./source_data/intact-micluster.zip")){
        download.file(url="ftp://ftp.ebi.ac.uk/pub/databases/intact/current/psimitab/intact-micluster.zip",destfile = "./source_data/intact-micluster.zip",method = "curl")
}


setwd("./source_data")
system("unzip -j intact.zip")
intact <- unique(fread(
  "intact.txt",
  header=T,
  sep="\t",
  colClasses="character",
  check.names = T,
  stringsAsFactors = F))
system("rm intact.txt")
system("rm intact_negative.txt")

system("unzip -j intact-micluster.zip")
intact_micluster <- unique(fread(
  "intact-micluster.txt",
  header=T,
  sep="\t",
  colClasses="character",
  check.names = T,
  stringsAsFactors = F))
system("rm intact-micluster.txt")
system("rm intact-micluster_negative.txt")
setwd("../")
```

### Extract comparison sets
```{r comp_sets}
eval_dsp_pmids <- unique(eval_dsp[grepl("yes|Yes",curatable),.(pmid)])

# eval_dsp_pmids_evaluated <- unique(eval_dsp[curatable!="",.(pmid,curatable)])
# fwrite(
#   eval_dsp_pmids,
#   "./source_data/pmids.txt",
#   col.names = F,
#   row.names = F,
#   sep = "\t",
#   quote = F
# )

eval_dsp_pairs <- unique(eval_dsp[grepl("yes|Yes",curatable),.(
  prot_pairs,
  pmid,
  DS.interest.up,
  DS.part_interest.up,
  DS.score.pred)])

eval_dsp_pairs_long <- unique(cSplit(
  eval_dsp_pairs,
  splitCols = "prot_pairs",
  sep = "|",
  direction = "long",
  drop = F
))

eval_dsp_pairs_formatted <- eval_dsp_pairs_long[,.(
  pmids = paste(unique(pmid),collapse = "|"),
  p1 = gsub("_.*", "",prot_pairs),
  p2 = gsub(".*_", "",prot_pairs),
  DS.interest.up,
  DS.part_interest.up,
  DS.score.pred
), by = "prot_pairs"]

intact_human <- intact[grepl('taxid:9606',Taxid.interactor.A) &
                         grepl('taxid:9606',Taxid.interactor.B) &
                         grepl('uniprotkb:',X.ID.s..interactor.A) &
                         grepl('uniprotkb:',ID.s..interactor.B),]
intact_human <- intact_human[,pmid:=gsub("\\|.*","",gsub(".*pubmed:","",Publication.Identifier.s.))]
intact_human <- intact_human[,p1:=gsub("-.*","",gsub("uniprotkb:","",X.ID.s..interactor.A))]
intact_human <- intact_human[,p2:=gsub("-.*","",gsub("uniprotkb:","",ID.s..interactor.B))]
intact_human <- intact_human[,pair_id := apply(data.table(p1,p2,stringsAsFactors = F),
                  1,
                  function(a) { z = sort(a)
                  paste0(z[1],"_",z[2]) })]

intact_human <- data.table(mutate(intact_human,
                                  X.ID.s..interactor.A = paste("uniprotkb:",p1,sep=""),
                                  ID.s..interactor.B = paste("uniprotkb:",p2,sep="")))

publs_curated_dsp <- intact_human[pmid %in% eval_dsp_pmids$pmid]

intact_dsp <- intact_human[(pmid %in% eval_dsp_pmids$pmid)]
dsp_pairs_in_intact <- unique(intact_dsp[,.(
  p1,
  p2,
  pair_id = apply(data.table(p1,p2,stringsAsFactors = F),
                  1,
                  function(a) { z = sort(a)
                  paste0(z[1],"_",z[2]) })
)])

intact_pairs_dsp <- intact_human[(p1 %in% dsp_pairs_in_intact$p1 & p2 %in% dsp_pairs_in_intact$p2) | (p1 %in% dsp_pairs_in_intact$p2 & p2 %in% dsp_pairs_in_intact$p1)]

intact_pairs_dsp_no_dsppmids <- intact_pairs_dsp[!(pmid %in% eval_dsp_pmids$pmid)]

intact_pairs_dsp_mitab <- intact_pairs_dsp[ ,`:=`(pmid = NULL, p1 = NULL, p2 = NULL, pair_id = NULL)]
fwrite(
  intact_pairs_dsp_mitab,
  "./processed_data/intact_pairs_dsp_mitab.txt",
  col.names = T,
  row.names = F,
  quote = F,
  sep = "\t"
)

intact_pairs_dsp_no_dsppmids_mitab <- intact_pairs_dsp_no_dsppmids[ ,`:=`(pmid = NULL, p1 = NULL, p2 = NULL, pair_id = NULL)]
fwrite(
  intact_pairs_dsp_no_dsppmids_mitab,
  "./processed_data/intact_pairs_dsp_no_dsppmids_mitab.txt",
  col.names = T,
  row.names = F,
  quote = F,
  sep = "\t"
)
```

#### Obtain non-DSP publication sets for comparison
I need to have a set publications unrelated with the DSP, for which I run the same comparison as I do for the DSP publications. I select these among low-through put publications, checking what is the maximum amount of expanded interactions that DSP publications have. I decide to produce two sets, one that covered the time frame during which the DSP has been active and another predating it. The reason for this is that Margaret was specifically targeting proteins with no UniProt CC lines during the time of the DSP, so it could appear as if the 'control' set is actually better than the DSP at finding novel interacting pairs. 

##### CC lines subset
```{r random_cclines}
# Count expanded interactions
publ_count_exp_int <- unique(intact_human[,.(
  nr_exp_ints = .N,
  Creation.date = as.Date(Creation.date, "%Y/%m/%d"),
  Source.database.s.
),
by = "pmid"])

# Map to DSP publications
eval_dsp_pmids_count <- unique(merge(
  eval_dsp_pmids,
  publ_count_exp_int,
  by = "pmid",
  all.x = T,
  all.y = F
))

# Max number of expanded binaries per DSP publication
max(eval_dsp_pmids_count[!is.na(nr_exp_ints)]$nr_exp_ints)


# Select low-throughput publications only from intact_human
lt_publs <- publ_count_exp_int[nr_exp_ints < 100]

# Select the subset of publications, roughly within the same period as DSP, which do not include DSP pairs and excluding DIP records, since they come from mass import and the creation date is not indicative of when they were curated. 
lt_publs_no_dsp_year <- lt_publs[Creation.date >= min(eval_dsp_pmids_count[!is.na(nr_exp_ints)]$Creation.date) &
                                   Creation.date <= max(eval_dsp_pmids_count[!is.na(nr_exp_ints)]$Creation.date) &
                                   !(pmid %in% eval_dsp_pmids$pmid) &
                                   Source.database.s. != 'psi-mi:"MI:0465"(DIP)']

# Select protein pairs from these publications
no_dsp_pairs <- unique(intact_human[pmid %in% lt_publs_no_dsp_year$pmid &
                                      !is.na(p1) &
                                      !is.na(p2),.(
  p1,
  p2,
  pair_id = apply(data.table(p1,p2,stringsAsFactors = F),
                  1,
                  function(a) { z = sort(a)
                  paste0(z[1],"_",z[2]) })
)])

# Produce adequate MITAB files for non DSP publications selected. REMEMBER TO PUT A HASH ON THE COLUMN TITLES!!!
intact_pairs_nodsp <- intact_human[((p1 %in% no_dsp_pairs$p1 & p2 %in% no_dsp_pairs$p2) | (p1 %in% no_dsp_pairs$p2 & p2 %in% no_dsp_pairs$p1)) & Source.database.s. != 'psi-mi:"MI:0465"(DIP)']
intact_pairs_nodsp_no_dsppmids <- intact_pairs_nodsp[!(pmid %in% lt_publs_no_dsp_year$pmid)]

intact_pairs_nodsp_mitab <- intact_pairs_nodsp[ ,`:=`(pmid = NULL, p1 = NULL, p2 = NULL, pair_id = NULL)]
fwrite(
  intact_pairs_nodsp_mitab,
  "./processed_data/intact_pairs_nodsp_mitab.txt",
  col.names = T,
  row.names = F,
  quote = F,
  sep = "\t"
)

intact_pairs_nodsp_no_dsppmids_mitab <- intact_pairs_nodsp_no_dsppmids[ ,`:=`(pmid = NULL, p1 = NULL, p2 = NULL, pair_id = NULL)]
fwrite(
  intact_pairs_nodsp_no_dsppmids_mitab,
  "./processed_data/intact_pairs_nodsp_no_dsppmids_mitab.txt",
  col.names = T,
  row.names = F,
  quote = F,
  sep = "\t"
)
```

##### Old random subset
```{r random_old}
# Select the subset of publications, well before DSP, which do not include DSP pairs and excluding MINT records, since they come from mass import and the creation date is not indicative of when they were curated. 
lt_publs_no_dsp_old_year <- lt_publs[Creation.date >= "2014-06-01" &
                                   Creation.date <= "2016-01-21" &
                                   !(pmid %in% eval_dsp_pmids$pmid) &
                                   grepl("MINT",Source.database.s.)]

# Select protein pairs from these publications
no_dsp_old_pairs <- unique(intact_human[pmid %in% lt_publs_no_dsp_old_year$pmid &
                                      !is.na(p1) &
                                      !is.na(p2),.(
  p1,
  p2,
  pair_id = apply(data.table(p1,p2,stringsAsFactors = F),
                  1,
                  function(a) { z = sort(a)
                  paste0(z[1],"_",z[2]) })
)])

# Produce adequate MITAB files for non DSP publications selected. REMEMBER TO PUT A HASH ON THE COLUMN TITLES!!!
intact_pairs_nodsp_old <- intact_human[((p1 %in% no_dsp_old_pairs$p1 & p2 %in% no_dsp_old_pairs$p2) | (p1 %in% no_dsp_old_pairs$p2 & p2 %in% no_dsp_old_pairs$p1)) &  grepl("MINT",Source.database.s.)]
intact_pairs_nodsp_old_no_dsppmids <- intact_pairs_nodsp_old[!(pmid %in% lt_publs_no_dsp_old_year$pmid)]

intact_pairs_nodsp_old_mitab <- intact_pairs_nodsp_old[ ,`:=`(pmid = NULL, p1 = NULL, p2 = NULL, pair_id = NULL)]
fwrite(
  intact_pairs_nodsp_old_mitab,
  "./processed_data/intact_pairs_nodsp_old_mitab.txt",
  col.names = T,
  row.names = F,
  quote = F,
  sep = "\t"
)

intact_pairs_nodsp_old_no_dsppmids_mitab <- intact_pairs_nodsp_old_no_dsppmids[ ,`:=`(pmid = NULL, p1 = NULL, p2 = NULL, pair_id = NULL)]
fwrite(
  intact_pairs_nodsp_old_no_dsppmids_mitab,
  "./processed_data/intact_pairs_nodsp_old_no_dsppmids_mitab.txt",
  col.names = T,
  row.names = F,
  quote = F,
  sep = "\t"
)
```

### Uploading MIscore before/after
I get the MIscore values applying the algorithm on the local files produced in the previous step. REMEMBER TO PUT A HASH ON THE COLUMN TITLES!!!
```{r miscore_upload}
intact_pairs_dsp_mitab_miscore <- fread(
  "./processed_data/intact_pairs_dsp_clustered.txt",
  header = F,
  check.names = T,
  stringsAsFactors = F,
  colClasses = "character"
)
colnames(intact_pairs_dsp_mitab_miscore) <- colnames(intact_pairs_dsp_no_dsppmids_mitab)[1:15]

intact_pairs_dsp_no_dsppmids_mitab_miscore <- fread(
  "./processed_data/intact_pairs_dsp_no_dsppmids_clustered.txt",
  header = F,
  check.names = T,
  stringsAsFactors = F,
  colClasses = "character"
)
colnames(intact_pairs_dsp_no_dsppmids_mitab_miscore) <- colnames(intact_pairs_dsp_no_dsppmids_mitab)[1:15]

intact_pairs_nodsp_mitab_miscore <- fread(
  "./processed_data/intact_pairs_nodsp_clustered.txt",
  header = F,
  check.names = T,
  stringsAsFactors = F,
  colClasses = "character"
)
colnames(intact_pairs_nodsp_mitab_miscore) <- colnames(intact_pairs_dsp_no_dsppmids_mitab)[1:15]

intact_pairs_nodsp_no_dsppmids_mitab_miscore <- fread(
  "./processed_data/intact_pairs_nodsp_no_dsppmids_clustered.txt",
  header = F,
  check.names = T,
  stringsAsFactors = F,
  colClasses = "character"
)
colnames(intact_pairs_nodsp_no_dsppmids_mitab_miscore) <- colnames(intact_pairs_dsp_no_dsppmids_mitab)[1:15]

intact_pairs_nodsp_old_mitab_miscore <- fread(
  "./processed_data/intact_pairs_nodsp_old_clustered.txt",
  header = F,
  check.names = T,
  stringsAsFactors = F,
  colClasses = "character"
)
colnames(intact_pairs_nodsp_old_mitab_miscore) <- colnames(intact_pairs_dsp_no_dsppmids_mitab)[1:15]

intact_pairs_nodsp_old_no_dsppmids_mitab_miscore <- fread(
  "./processed_data/intact_pairs_nodsp_old_no_dsppmids_clustered.txt",
  header = F,
  check.names = T,
  stringsAsFactors = F,
  colClasses = "character"
)
colnames(intact_pairs_nodsp_old_no_dsppmids_mitab_miscore) <- colnames(intact_pairs_dsp_no_dsppmids_mitab)[1:15]
```


### Comparison before/after dsp
##### Preformat the data: DSP
```{r miscore_bef_after_dsp}
intact_pairs_dsp_after <- unique(intact_pairs_dsp_mitab_miscore[,.(
  pair_id = apply(data.table(gsub("uniprotkb:","",X.ID.s..interactor.A),
                             gsub("uniprotkb:","",ID.s..interactor.B),
                             stringsAsFactors = F),
                  1,
                  function(a) { z = sort(a)
                  paste0(z[1],"_",z[2]) }),
  miscore_after = as.numeric(gsub(".*miscore:","",Confidence.value.s.)))])

intact_pairs_dsp_before <- unique(intact_pairs_dsp_no_dsppmids_mitab_miscore[,.(
  # p1 = gsub("-.*","",gsub("uniprotkb:","",X.ID.s..interactor.A)),
  # p2 = gsub("-.*","",gsub("uniprotkb:","",ID.s..interactor.B)),
  pair_id = apply(data.table(gsub("uniprotkb:","",X.ID.s..interactor.A),
                             gsub("uniprotkb:","",ID.s..interactor.B),
                             stringsAsFactors = F),
                  1,
                  function(a) { z = sort(a)
                  paste0(z[1],"_",z[2]) }),
  miscore_before = as.numeric(gsub(".*miscore:","",Confidence.value.s.)))])

comp_pairs_dsp_miscore <- unique(merge(
  intact_pairs_dsp_before,
  intact_pairs_dsp_after,
  by = "pair_id",
  all = T
  ))

comp_pairs_dsp_miscore[is.na(miscore_before)]$miscore_before <- 0
comp_pairs_dsp_miscore[,diff:=(miscore_after-miscore_before)]
comp_pairs_dsp_miscore[,set:="dsp"]
```

##### Preformat the data: non-DSP cc-lines
```{r miscore_bef_after_nodsp}
intact_pairs_nodsp_after <- unique(intact_pairs_nodsp_mitab_miscore[,.(
  # p1 = gsub("-.*","",gsub("uniprotkb:","",X.ID.s..interactor.A)),
  # p2 = gsub("-.*","",gsub("uniprotkb:","",ID.s..interactor.B)),
  pair_id = apply(data.table(gsub("uniprotkb:","",X.ID.s..interactor.A),
                             gsub("uniprotkb:","",ID.s..interactor.B),
                             stringsAsFactors = F),
                  1,
                  function(a) { z = sort(a)
                  paste0(z[1],"_",z[2]) }),
  miscore_after = as.numeric(gsub(".*miscore:","",Confidence.value.s.)))])

intact_pairs_nodsp_before <- unique(intact_pairs_nodsp_no_dsppmids_mitab_miscore[,.(
  # p1 = gsub("-.*","",gsub("uniprotkb:","",X.ID.s..interactor.A)),
  # p2 = gsub("-.*","",gsub("uniprotkb:","",ID.s..interactor.B)),
  pair_id = apply(data.table(gsub("uniprotkb:","",X.ID.s..interactor.A),
                             gsub("uniprotkb:","",ID.s..interactor.B),
                             stringsAsFactors = F),
                  1,
                  function(a) { z = sort(a)
                  paste0(z[1],"_",z[2]) }),
  miscore_before = as.numeric(gsub(".*miscore:","",Confidence.value.s.)))])

comp_pairs_nodsp_miscore <- unique(merge(
  intact_pairs_nodsp_before,
  intact_pairs_nodsp_after,
  by = "pair_id",
  all = T
  ))

comp_pairs_nodsp_miscore[is.na(miscore_before)]$miscore_before <- 0
comp_pairs_nodsp_miscore[,diff:=(miscore_after-miscore_before)]
comp_pairs_nodsp_miscore[,set:="control cc-lines"]
```

##### Preformat the data: non-DSP old
```{r miscore_bef_after_nodsp_old}
intact_pairs_nodsp_old_after <- unique(intact_pairs_nodsp_old_mitab_miscore[,.(
  # p1 = gsub("-.*","",gsub("uniprotkb:","",X.ID.s..interactor.A)),
  # p2 = gsub("-.*","",gsub("uniprotkb:","",ID.s..interactor.B)),
  pair_id = apply(data.table(gsub("uniprotkb:","",X.ID.s..interactor.A),
                             gsub("uniprotkb:","",ID.s..interactor.B),
                             stringsAsFactors = F),
                  1,
                  function(a) { z = sort(a)
                  paste0(z[1],"_",z[2]) }),
  miscore_after = as.numeric(gsub(".*miscore:","",Confidence.value.s.)))])

intact_pairs_nodsp_old_before <- unique(intact_pairs_nodsp_old_no_dsppmids_mitab_miscore[,.(
  # p1 = gsub("-.*","",gsub("uniprotkb:","",X.ID.s..interactor.A)),
  # p2 = gsub("-.*","",gsub("uniprotkb:","",ID.s..interactor.B)),
  pair_id = apply(data.table(gsub("uniprotkb:","",X.ID.s..interactor.A),
                             gsub("uniprotkb:","",ID.s..interactor.B),
                             stringsAsFactors = F),
                  1,
                  function(a) { z = sort(a)
                  paste0(z[1],"_",z[2]) }),
  miscore_before = as.numeric(gsub(".*miscore:","",Confidence.value.s.)))])

comp_pairs_nodsp_old_miscore <- unique(merge(
  intact_pairs_nodsp_old_before,
  intact_pairs_nodsp_old_after,
  by = "pair_id",
  all = T
  ))

comp_pairs_nodsp_old_miscore[is.na(miscore_before)]$miscore_before <- 0
comp_pairs_nodsp_old_miscore[,diff:=(miscore_after-miscore_before)]
comp_pairs_nodsp_old_miscore[,set:="control"]
```

#### Explore differences statistics
```{r diff_stats}
comp_pairs_miscore <- unique(rbind(
  comp_pairs_dsp_miscore,
  comp_pairs_nodsp_miscore,
  comp_pairs_nodsp_old_miscore
))

# Wilcoxon test to check if MIscore gain is greater in DSP rather than control or viceversa 
wilcox.test.altg = function(x, y) wilcox.test(x, y, alternative = 'g')
wilcox.test.altl = function(x, y) wilcox.test(x, y, alternative = 'l')
wilcox.test.altg(comp_pairs_miscore[diff!=0 & set == "dsp"]$diff,comp_pairs_miscore[diff!=0 & set == "control"]$diff)
wilcox.test.altl(comp_pairs_miscore[diff!=0 & set == "dsp"]$diff,comp_pairs_miscore[diff!=0 & set == "control"]$diff)
wilcox.test.altg(comp_pairs_miscore[diff!=0 & set == "dsp"]$diff,comp_pairs_miscore[diff!=0 & set == "control cc-lines"]$diff)
wilcox.test.altl(comp_pairs_miscore[diff!=0 & set == "dsp"]$diff,comp_pairs_miscore[diff!=0 & set == "control cc-lines"]$diff)

# Summary statistics

## Old control vs DSP
new_pairs <- data.table(
  dsp = c(nrow(comp_pairs_miscore[set=="dsp" & miscore_before==0]),nrow(comp_pairs_miscore[set=="dsp" & miscore_before!=0])),
  control = c(nrow(comp_pairs_miscore[set=="control" & miscore_before==0]),nrow(comp_pairs_miscore[set=="control" & miscore_before!=0]))
)
new_pairs_matrix <- as.matrix(new_pairs)
fisher.test(new_pairs_matrix,
            alternative="two.sided")

unaff_pairs <- data.table(
  dsp = c(nrow(comp_pairs_miscore[set=="dsp" & diff==0]),nrow(comp_pairs_miscore[set=="dsp" & diff!=0])),
  control = c(nrow(comp_pairs_miscore[set=="control" & diff==0]),nrow(comp_pairs_miscore[set=="control" & diff!=0]))
)

unaff_pairs_matrix <- as.matrix(unaff_pairs)
fisher.test(unaff_pairs_matrix,
            alternative="two.sided")

## CC-lines control vs DSP
new_pairs_cc <- data.table(
  dsp = c(nrow(comp_pairs_miscore[set=="dsp" & miscore_before==0]),nrow(comp_pairs_miscore[set=="dsp" & miscore_before!=0])),
  control_cc = c(nrow(comp_pairs_miscore[set=="control cc-lines" & miscore_before==0]),nrow(comp_pairs_miscore[set=="control cc-lines" & miscore_before!=0]))
)
new_pairs_cc_matrix <- as.matrix(new_pairs_cc)
fisher.test(new_pairs_cc_matrix,
            alternative="two.sided")

unaff_pairs_cc <- data.table(
  dsp = c(nrow(comp_pairs_miscore[set=="dsp" & diff==0]),nrow(comp_pairs_miscore[set=="dsp" & diff!=0])),
  control_cc = c(nrow(comp_pairs_miscore[set=="control cc-lines" & diff==0]),nrow(comp_pairs_miscore[set=="control cc-lines" & diff!=0]))
)

unaff_pairs_cc_matrix <- as.matrix(unaff_pairs_cc)
fisher.test(unaff_pairs_cc_matrix,
            alternative="two.sided")

## CC-lines control vs old control
new_pairs_cc_ctrl <- data.table(
  control = c(nrow(comp_pairs_miscore[set=="control" & miscore_before==0]),nrow(comp_pairs_miscore[set=="control" & miscore_before!=0])),
  control_cc = c(nrow(comp_pairs_miscore[set=="control cc-lines" & miscore_before==0]),nrow(comp_pairs_miscore[set=="control cc-lines" & miscore_before!=0]))
)
new_pairs_cc_ctrl_matrix <- as.matrix(new_pairs_cc_ctrl)
fisher.test(new_pairs_cc_ctrl_matrix,
            alternative="two.sided")

unaff_pairs_cc_ctrl <- data.table(
  control = c(nrow(comp_pairs_miscore[set=="control" & diff==0]),nrow(comp_pairs_miscore[set=="control" & diff!=0])),
  control_cc = c(nrow(comp_pairs_miscore[set=="control cc-lines" & diff==0]),nrow(comp_pairs_miscore[set=="control cc-lines" & diff!=0]))
)

unaff_pairs_cc_ctrl_matrix <- as.matrix(unaff_pairs_cc_ctrl)
fisher.test(unaff_pairs_cc_ctrl_matrix,
            alternative="two.sided")
```
I find no significant change in the amount of new pairs discovered through DSP in comparison with the cc-lines control, but both DSP and cc-lines control show a significant difference with the old control.  

#### Plot differences
```{r diff_plot}
g <- ggplot(comp_pairs_miscore[diff!=0], aes(x=set,y=diff)) +
  geom_violin() +
  geom_jitter(alpha=0.2) +
  ylab('MIscore net gain') + 
  xlab('') +
  geom_signif(comparisons = list(c("control","dsp"),
                                 c("control cc-lines","dsp"),
                                 c("control","control cc-lines")),
  # geom_signif(comparisons = c("dsp","control"),
              step_increase=0.07,
              test = wilcox.test.altg,
              tip_length = 0.015,
              textsize = 5) +
  theme(plot.title = element_text(),
        legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line = element_line(),
        axis.text.x = element_text(size=16),
        axis.text.y = element_text(size=16),
        axis.title = element_text(size=18))
g
```



## Correlate interest scores with MIscore progression
If interest score really helps targeting lowly annotated pairs, it should correlate with bigger differences in MIscore progression. This comparison is only possible for DSP-curated papers, of course.  
```{r interest_miscore}
pairs_int_comp <- unique(merge(
  eval_dsp_pairs_formatted,
  comp_pairs_dsp_miscore,
  by.x = "prot_pairs",
  by.y = "pair_id",
  all = F
))

fwrite(
  pairs_int_comp,
  "./processed_data/pairs_int_comp.txt",
  col.names = T,
  row.names = F,
  quote = F,
  sep = "\t"
)
```

### Plots interest scores vs MIscore
```{r plot_intvsmiscore_1}
g1 <- ggplot(pairs_int_comp,aes(x=as.numeric(DS.interest.up),y=diff)) +
  geom_point(alpha = 0.2) + 
  geom_smooth(method='lm') +
  ylab('MIscore net gain') + 
  xlab('DSP interest score') +
  theme(plot.title = element_text(),
        legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line = element_line(),
        axis.text.x = element_text(size=16),
        axis.text.y = element_text(size=16),
        axis.title = element_text(size=18))
g1
```

```{r plot_intvsmiscore_2}
g2 <- ggplot(pairs_int_comp,aes(x=as.numeric(DS.part_interest.up),y=diff)) +
  geom_point(alpha = 0.2) + 
  geom_smooth(method='lm') +
  ylab('MIscore net gain') + 
  xlab('DSP interest score, partial') +
  theme(plot.title = element_text(),
        legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line = element_line(),
        axis.text.x = element_text(size=16),
        axis.text.y = element_text(size=16),
        axis.title = element_text(size=18))
g2
```

```{r plot_intvsmiscore_3}
g3 <- ggplot(pairs_int_comp,aes(x=as.numeric(DS.score.pred),y=diff)) +
  geom_point(alpha = 0.2) + 
  geom_smooth(method='lm') +
  ylab('MIscore net gain') + 
  xlab('DSP interest score, with predictions') +
  theme(plot.title = element_text(),
        legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line = element_line(),
        axis.text.x = element_text(size=16),
        axis.text.y = element_text(size=16),
        axis.title = element_text(size=18))
g3
```

Any version of the interest score is all over the place, with poor correlation with MIscore gains. The correlation seems to be actually negative, if anything. 

## Normalization problem evaluation
Let's check how much of a problem we have with identification of interacting pairs in text mining and predicted datasets. 
```{r normeval}
curated_dsp_sel <-unique(eval_dsp[grepl("yes|Yes",curatable) & pmid %in% publs_curated_dsp$pmid,.(
  pair_id= prot_pairs,
  pmid,
  text_mined = ifelse(
    tm_epmc_pair == "yes" | EVEX_pair == "yes" | STRING_textmining_pair == "yes",
    "yes",
    ifelse(
      tm_epmc_pair == "part" | EVEX_pair == "part" | STRING_textmining_pair == "part",
      "part",
      "no"
    )
  ),
  pw_curated = ifelse(
    reactome_pair == "yes" | OmniPath_interactions_pair == "yes" | OmniPath_ptm_pair == "yes" | STRING_pi_pair == "yes",
    "yes",
    ifelse(
      reactome_pair == "part" | OmniPath_interactions_pair == "part" | OmniPath_ptm_pair == "part" | STRING_pi_pair == "part",
      "part",
      "no"
    )
  ),
  predicted = ifelse(
    iid_pred == "yes",
    "yes",
    ifelse(
       iid_pred == "part",
      "part",
      "no"
    )
  )
  )])

curated_dsp_long <- cSplit(
  curated_dsp_sel,
  splitCols = "pair_id",
  sep = "|",
  direction = "long",
  drop = F
)

intact_pairs_dsp_sel <- intact_human[pmid %in% publs_curated_dsp$pmid,.(
  pmid,
  pair_id,
  imex_curated = "yes"
)]

predicted_vs_curated_dsp_pairs <- unique(merge(
  curated_dsp_long,
  intact_pairs_dsp_sel,
  by = c("pair_id","pmid"),
  all = T
))

predicted_vs_curated_dsp_pairs_annot <- predicted_vs_curated_dsp_pairs[,.(
  pair_id,
  pmid,
  match = ifelse(
    imex_curated == "yes" & is.na(text_mined),
    "not DSP predicted",
    ifelse(
      imex_curated == "yes" & (text_mined == "yes" | pw_curated == "yes" | predicted == "yes"),
      "full match",
      ifelse(
        imex_curated == "yes" & (text_mined == "part" | pw_curated == "part" | predicted == "part"),
        "partial match",
        "false identification"
      )
    )
  ),
  imex_curated,
  text_mined,
  pw_curated,
  predicted
)]

table(predicted_vs_curated_dsp_pairs_annot$match,useNA="ifany")

true_positives_overview <- melt(
  predicted_vs_curated_dsp_pairs_annot[match=="full match"],
  id.vars = c("pmid","pair_id"),
  measure.vars = c("text_mined","pw_curated","predicted"))

table(true_positives_overview$variable,
      true_positives_overview$value,
      useNA = "ifany")

part_positives_overview <- melt(
  predicted_vs_curated_dsp_pairs_annot[match=="partial match"],
  id.vars = c("pmid","pair_id"),
  measure.vars = c("text_mined","pw_curated","predicted"))

table(part_positives_overview$variable,
      part_positives_overview$value,
      useNA = "ifany")

false_positives_overview <- melt(
  predicted_vs_curated_dsp_pairs_annot[is.na(match)],
  id.vars = c("pmid","pair_id"),
  measure.vars = c("text_mined","pw_curated","predicted"))

table(false_positives_overview$variable,
      false_positives_overview$value,
      useNA = "ifany")

table(predicted_vs_curated_dsp_pairs_annot$text_mined,useNA = "ifany")
table(predicted_vs_curated_dsp_pairs_annot$pw_curated,useNA = "ifany")
table(predicted_vs_curated_dsp_pairs_annot$predicted,useNA = "ifany")
```

### Manual evaluation specific pairs
```{r eval_miscore_interest_score_manual}
pairs_int_comp_long <- cSplit(
  pairs_int_comp,
  "pmids",
  sep = "|",
  drop = F,
  direction = "long"
)

pairs_int_comp_long <- pairs_int_comp_long[,pmid:=as.character(pmids)]

pairs_int_comp_prepairs <- unique(merge(
  pairs_int_comp_long,
  curated_dsp_long[,.(
    pmid,
    pred_prot_pairs=pair_id,
    pred_p1 = gsub("_.*","",pair_id),
    pred_p2 = gsub(".*_","",pair_id))],
  allow.cartesian = T,
  by = "pmid",
  all.x = T,
  all.y = F
))

prots <- unique(rbind(
  unique(pairs_int_comp_prepairs[,.(p = p1)]),
  unique(pairs_int_comp_prepairs[,.(p = p2)]),
  unique(pairs_int_comp_prepairs[,.(p = pred_p1)]),
  unique(pairs_int_comp_prepairs[,.(p = pred_p2)])
))

# fwrite(
#   prots,
#   "./processed_data/prots.txt",
#   col.names = F,
#   row.names = F,
#   sep = "\t",
#   quote = F
# )
## I checked and every protein in the list is human, so I can use the UniProt.ws package to get some more info about them (gene names).

prot_list <- prots$p
up <- UniProt.ws(taxId=9606)

prots_genenames <- select(
        up,
        keys = prot_list,
        columns = c("GENES","ENTRY-NAME")
)

pairs_man_eval_pt1 <- unique(merge(
  pairs_int_comp_prepairs,
  prots_genenames,
  by.x = "p1",
  by.y = "UNIPROTKB",
  all.x = T,
  all.y = F
))

pairs_man_eval_pt2 <- unique(merge(
  pairs_man_eval_pt1,
  prots_genenames,
  by.x = "p2",
  by.y = "UNIPROTKB",
  all.x = T,
  all.y = F
))

pairs_man_eval_pt3 <- unique(merge(
  pairs_man_eval_pt2,
  prots_genenames,
  by.x = "pred_p1",
  by.y = "UNIPROTKB",
  all.x = T,
  all.y = F
))

colnames(pairs_man_eval_pt3) <- c("pred_p1","p2","p1","pmid","prot_pairs","pmids","DS.interest.up","DS.part_interest.up","DS.score.pred","miscore_before","miscore_after","diff","set","pred_prot_pairs","pred_p2","p1_genenames","p1_upid","p2_genenames","p2_upid","pred_p1_genenames","pred_p1_upid")

pairs_man_eval_pt4 <- unique(merge(
  pairs_man_eval_pt3,
  prots_genenames,
  by.x = "pred_p2",
  by.y = "UNIPROTKB",
  all.x = T,
  all.y = F
))

pairs_man_eval <- pairs_man_eval_pt4[,.(
  pmid,
  DS.interest.up,
  DS.part_interest.up,
  DS.score.pred,
  miscore_before,
  miscore_after,
  diff,
  set,
  prot_pairs,
  pred_prot_pairs,
  p1,
  p1_genenames,
  p1_upid,
  pred_p1,
  pred_p1_genenames,
  pred_p1_upid,
  p2,
  p2_genenames,
  p2_upid,
  pred_p2,
  pred_p2_genenames = GENES,
  pred_p2_upid = `ENTRY-NAME`
)]

prot_preds <- unique(rbind(
  unique(pairs_man_eval[,.(p = p1,pred_p=pred_p1,p_gs=p1_genenames,pred_p_gs=pred_p1_genenames)]),
  unique(pairs_man_eval[,.(p = p2,pred_p=pred_p2,p_gs=p2_genenames,pred_p_gs=pred_p2_genenames)])
))

prot_preds_qual <- unique(prot_preds[,.(
  p,
  pred_p,
  wrong_pred_p = ifelse(
    is.na(pred_p),
    "no map",
    ifelse(
      p != pred_p,
      "1",
      "0"
    )
  ),
  p_gs,
  pred_p_gs
)])

fwrite(
  prot_preds_qual,
  "./processed_data/prot_preds_qual.txt",
  col.names = T,
  row.names = F,
  quote = F,
  sep = "\t"
)
```

I evaluate individually each of the text-mined id predictions, grouping the wrong predictions in two categories: those cases where I could find exact synonyms for the gene symbol for the real id and the predicted one in UniProt and those where a close synonym was found. Close synonyms are cases of gene names sharing the same root (first few letters), but different suffix (ordinarily, subunit number, in some cases there is an additional letter). I account these two categories in different columns.

```{r eval_miscore_interest_score_manual_ii}
prot_preds_qual_manual <- data.table(read_excel(
  "./processed_data/prot_preds_qual_manual.xlsx",
  sheet = 1,
  col_names = T,
  col_types = "text"
),
check.names = T)

pairs_man_eval_diagn_pt1 <- unique(merge(
  pairs_man_eval,
  prot_preds_qual_manual,
  by.x = c("p1","p1_genenames","pred_p1","pred_p1_genenames"),
  by.y = c("p","p_gs","pred_p","pred_p_gs"),
  all.x = T,
  all.y = F
))

pairs_man_eval_diagn_pt2 <- unique(merge(
  pairs_man_eval_diagn_pt1,
  prot_preds_qual_manual,
  by.x = c("p2","p2_genenames","pred_p2","pred_p2_genenames"),
  by.y = c("p","p_gs","pred_p","pred_p_gs"),
  all.x = T,
  all.y = F
))

pairs_man_eval_diagn_pt3 <- unique(pairs_man_eval_diagn_pt2[,.(
  pmid,
  DS.interest.up,
  DS.part_interest.up,
  DS.score.pred,
  miscore_before,
  miscore_after,
  diff,
  prot_pairs,
  pred_prot_pairs,
  wrong_pred_p1 = ifelse(
    is.na(wrong_pred_p.x),
    NA,
    as.numeric(wrong_pred_p.x)
  ),
  pred_syn_p1 = ifelse(
    is.na(wrong_pred_p.x),
    NA,
    ifelse(
      is.na(pred_synonym.x) | pred_synonym.x == "",
      0,
      as.numeric(pred_synonym.x)
    )
  ),
  pred_close_syn_p1 = ifelse(
    is.na(wrong_pred_p.x),
    NA,
    ifelse(
      is.na(pred_close_syn.x) | pred_close_syn.x == "",
      0,
      as.numeric(pred_close_syn.x)
    )
  ),
  wrong_pred_p2 = ifelse(
    is.na(wrong_pred_p.y),
    NA,
    as.numeric(wrong_pred_p.y)
  ),
  pred_syn_p2 = ifelse(
    is.na(wrong_pred_p.y),
    NA,
    ifelse(
      is.na(pred_synonym.y) | pred_synonym.y == "",
      0,
      as.numeric(pred_synonym.y)
    )
  ),
  pred_close_syn_p2 = ifelse(
    is.na(wrong_pred_p.y),
    NA,
    ifelse(
      is.na(pred_close_syn.y) | pred_close_syn.y == "",
      0,
      as.numeric(pred_close_syn.y)
    )
  )
)])

pairs_man_eval_diagn <- data.table(mutate(
  pairs_man_eval_diagn_pt3[!is.na(wrong_pred_p1) & !is.na(wrong_pred_p2)],
  wrong_score = wrong_pred_p1 + wrong_pred_p2,
  syn_score = pred_syn_p1 + pred_syn_p2,
  close_syn_score = pred_close_syn_p1 + pred_close_syn_p2,
  full_syn_score = pred_syn_p1 + pred_syn_p2 + pred_close_syn_p1 + pred_close_syn_p2))

table(pairs_man_eval_diagn$wrong_score,useNA="ifany")
table(pairs_man_eval_diagn$syn_score,useNA="ifany")
table(pairs_man_eval_diagn$close_syn_score,useNA="ifany")
table(pairs_man_eval_diagn$full_syn_score,useNA="ifany")

pair_normalization_man_eval <- unique(pairs_man_eval_diagn[,.(
  pred_prot_pairs = paste(unique(pred_prot_pairs),collapse="|"),
  DS.interest.up,
  DS.part_interest.up,
  DS.score.pred,
  diff,
  wrong_score_total = sum(wrong_score),
  syn_score_total = sum(syn_score),
  close_syn_score_total = sum(close_syn_score),
  full_syn_score_total = sum(full_syn_score)
), by = c("prot_pairs","pmid")])
```
#### Plots normalization problem evaluation
##### Wrong ids vs interest scores
First I check whether the different versions of the interest score correlate with a large number of misidentified pairs.
```{r plots_interest_i,echo=FALSE}
g8 <- ggplot(pair_normalization_man_eval,aes(x=wrong_score_total,y=as.numeric(DS.interest.up),color=diff)) +
  geom_point(alpha = 0.3) + 
  geom_smooth(method='lm') +
  xlab('Cumulative wrong identifications in protein pair') + 
  ylab('DSP interest score') +
  scale_color_gradient(low = "darkorchid", high = "gold",name="MIscore differential") +
  theme(plot.title = element_text(),
        legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line = element_line(),
        axis.text.x = element_text(size=16),
        axis.text.y = element_text(size=16),
        axis.title = element_text(size=18))
g8
```

```{r plots_interest_ii,echo=FALSE}
g9 <- ggplot(pair_normalization_man_eval,aes(x=wrong_score_total,y=as.numeric(DS.part_interest.up),color=diff)) +
  geom_point(alpha = 0.3) + 
  geom_smooth(method='lm') +
  xlab('Cumulative wrong identifications in protein pair') + 
  ylab('DSP partial interest score') +
  scale_color_gradient(low = "darkorchid", high = "gold",name="MIscore differential") +
  theme(plot.title = element_text(),
        legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line = element_line(),
        axis.text.x = element_text(size=16),
        axis.text.y = element_text(size=16),
        axis.title = element_text(size=18))
g9
```

```{r plots_interest_iii,echo=FALSE}
g10 <- ggplot(pair_normalization_man_eval,aes(x=close_syn_score_total,y=as.numeric(DS.score.pred),color=diff)) +
  geom_point(alpha = 0.3) + 
  geom_smooth(method='lm') +
  xlab('Cumulative wrong identifications in protein pair') + 
  ylab('DSP predicted interest score') +
  scale_color_gradient(low = "darkorchid", high = "gold",name="MIscore differential") +
  theme(plot.title = element_text(),
        legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line = element_line(),
        axis.text.x = element_text(size=16),
        axis.text.y = element_text(size=16),
        axis.title = element_text(size=18))
g10
```

It seems there is indeed a correlation, strongly alleviated by the use of predictions on the interest score calculation. 
##### Check synonyms influence
I divide the pairs in those strongly, mildly or not influenced by the presence of synonyms. 
```{r syn_eval}
pair_normalization_man_eval_syn <- data.table(mutate(
  pair_normalization_man_eval,
  syn_influence = ifelse(
    full_syn_score_total == 0,
    "no synonyms",
    ifelse(
      full_syn_score_total != 0 & full_syn_score_total <= 10,
      "mild synonyms content",
      "strong synonyms content"
    )
  ),
  exact_syn_influence = ifelse(
    syn_score_total == 0,
    "no exact synonyms",
    ifelse(
      syn_score_total != 0 & syn_score_total <= 10,
      "mild exact synonyms content",
      "strong exact synonyms content"
    )
  ),
  close_syn_influence = ifelse(
    close_syn_score_total == 0,
    "no close synonyms",
    ifelse(
      close_syn_score_total != 0 & close_syn_score_total <= 10,
      "mild close synonyms content",
      "strong close synonyms content"
    )
  )
))

pair_normalization_man_eval_syn <- data.table(mutate(
  pair_normalization_man_eval_syn,
  syn_influence = factor(syn_influence,levels = c("no synonyms","mild synonyms content","strong synonyms content")),
  close_syn_influence = factor(close_syn_influence,levels = c("no close synonyms","mild close synonyms content","strong close synonyms content")),
  exact_syn_influence = factor(exact_syn_influence,levels = c("no exact synonyms","mild exact synonyms content","strong exact synonyms content"))
))
```
```{r plot_syns_i,echo=FALSE}
g11 <- ggplot(pair_normalization_man_eval_syn,aes(x=wrong_score_total,y=as.numeric(DS.interest.up),color=diff)) +
  geom_point(alpha = 0.3) + 
  geom_smooth(method='lm') +
  facet_grid(.~syn_influence,scales = "free_x") +
  xlab('Cumulative wrong identifications in protein pair') + 
  ylab('DSP interest score') +
  scale_color_gradient(low = "darkorchid", high = "gold",name="MIscore differential") +
  theme(plot.title = element_text(),
        legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line = element_line(),
        axis.text.x = element_text(size=16),
        axis.text.y = element_text(size=16),
        axis.title = element_text(size=18))
g11
```

```{r plot_syns_ii,echo=FALSE}
g12 <- ggplot(pair_normalization_man_eval_syn,aes(x=wrong_score_total,y=as.numeric(DS.part_interest.up),color=diff)) +
  geom_point(alpha = 0.3) + 
  geom_smooth(method='lm') +
  facet_grid(.~syn_influence,scales = "free_x") +
  xlab('Cumulative wrong identifications in protein pair') + 
  ylab('DSP partial interest score') +
  scale_color_gradient(low = "darkorchid", high = "gold",name="MIscore differential") +
  theme(plot.title = element_text(),
        legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line = element_line(),
        axis.text.x = element_text(size=16),
        axis.text.y = element_text(size=16),
        axis.title = element_text(size=18))
g12
```

```{r plot_syns_iii,echo=FALSE}
g13 <- ggplot(pair_normalization_man_eval_syn,aes(x=wrong_score_total,y=as.numeric(DS.score.pred),color=diff)) +
  geom_point(alpha = 0.3) + 
  geom_smooth(method='lm') +
  facet_grid(.~syn_influence,scales = "free_x") +
  xlab('Cumulative wrong identifications in protein pair') + 
  ylab('DSP predicted interest score') +
  scale_color_gradient(low = "darkorchid", high = "gold",name="MIscore differential") +
  theme(plot.title = element_text(),
        legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line = element_line(),
        axis.text.x = element_text(size=16),
        axis.text.y = element_text(size=16),
        axis.title = element_text(size=18))
g13
```

It seems is mainly those close synonyms that are messing with the protein identifications and have a higher impact on the interest score. 

##### Wrong ids vs miscore
I plot the differential in MIscore obtained during the DSP project duration versus the wrong identification score I have calculated. Colour is now mapped to the different interest scores. 
```{r plots_miscore_i,echo=FALSE}
g4 <- ggplot(pair_normalization_man_eval,aes(x=wrong_score_total,y=diff,color=as.numeric(DS.interest.up))) +
  geom_point(alpha = 0.4) + 
  geom_smooth(method='lm') +
  xlab('Cumulative wrong identifications in protein pair') + 
  ylab('MIscore increase') +
  scale_color_gradient(low = "dodgerblue3", high = "darkgoldenrod1",name="DSP interest score") + 
  theme(plot.title = element_text(),
        legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line = element_line(),
        axis.text.x = element_text(size=16),
        axis.text.y = element_text(size=16),
        axis.title = element_text(size=18))
g4
```

```{r plots_miscore_ii,echo=FALSE}
g14 <- ggplot(pair_normalization_man_eval,aes(x=wrong_score_total,y=diff,color=as.numeric(DS.part_interest.up))) +
  geom_point(alpha = 0.4) + 
  geom_smooth(method='lm') +
  xlab('Cumulative wrong identifications in protein pair') + 
  ylab('MIscore increase') +
  scale_color_gradient(low = "dodgerblue3", high = "darkgoldenrod1",name="DSP partial interest score") + 
  theme(plot.title = element_text(),
        legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line = element_line(),
        axis.text.x = element_text(size=16),
        axis.text.y = element_text(size=16),
        axis.title = element_text(size=18))
g14
```

```{r plots_miscore_iii,echo=FALSE}
g15 <- ggplot(pair_normalization_man_eval,aes(x=wrong_score_total,y=diff,color=as.numeric(DS.score.pred))) +
  geom_point(alpha = 0.4) + 
  geom_smooth(method='lm') +
  xlab('Cumulative wrong identifications in protein pair') + 
  ylab('MIscore increase') +
  scale_color_gradient(low = "dodgerblue3", high = "darkgoldenrod1",name="DSP predicted interest score") + 
  theme(plot.title = element_text(),
        legend.position = "bottom",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line = element_line(),
        axis.text.x = element_text(size=16),
        axis.text.y = element_text(size=16),
        axis.title = element_text(size=18))
g15
```

It seems low increments in MIscore roughly correlate with number of wrongly identified pairs. 


## Evaluation of mutation data
This is for an unrelated issue: how many curated DSP publications ended up containing mutation data?
```{r muts}
dsp_muts_ints <- intact_dsp[grepl("mutation",Feature.s..interactor.A) | grepl("mutation",Feature.s..interactor.B)]
dsp_muts_publs <- unique(dsp_muts_ints[,.(Publication.Identifier.s.)])
```
There are `r nrow(dsp_muts_ints)` binaries with reported mutations curated, in `r nrow(dsp_muts_publs)` publications. 

## Evaluation of relevance score historic impact
I check the accuracy of the relevance score since it was introduced. 

```{r rel_check}
evaluated_old <- fread(
  "./source_data/pmids_pre_relevance.txt",
  check.names = T,
  header = T,
  sep = "\t",
  colClasses = "character",
  stringsAsFactors = F
)

evaluated_old_simple <- unique(evaluated_old[,.(
  pmid = PMID,
  eval_old = "yes"
)])

eval_dsp_pmids_rel <- unique(eval_dsp[curatable!="",.(
  pmid,
  curatable,
  relevance.up,
  relevance
)])

eval_dsp_rel_check <- unique(merge(
  eval_dsp_pmids_rel,
  evaluated_old_simple,
  by = "pmid",
  all = T
))

eval_dsp_rel_new <- eval_dsp_rel_check[is.na(eval_old),.(
  pmid,
  curatable,
  curatable_simple = ifelse(
    grepl("yes|Yes",curatable),
    "yes",
    "no"
  ),
  relevance = as.numeric(gsub(',','.',relevance)),
  relevance.up = as.numeric(relevance.up)
)]
table(eval_dsp_rel_new$curatable_simple,useNA="ifany")

g16 <- ggplot(eval_dsp_rel_new, aes(x=curatable_simple,y=relevance)) +
  geom_boxplot() +
  geom_jitter(alpha=0.2) +
  ylab('Relevance score') + 
  xlab('Curatable paper') +
  geom_signif(comparisons = list(c("yes","no")),
              step_increase=0.07,
              test = wilcox.test.altg,
              tip_length = 0.015,
              textsize = 4) +
  theme(plot.title = element_text(),
        legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_blank(),
        axis.line = element_line(),
        axis.text.x = element_text(size=16),
        axis.text.y = element_text(size=16),
        axis.title = element_text(size=18))
g16
```


**********
<!-- ### Debugging: Negative MIscore progression -->
<!-- Why do I have values with negative MIscore progression? It does not make any sense. I isolate those and run a test.  -->
<!-- ```{r debugmiscore} -->
<!-- test_after <- intact_human[pair_id %in% comp_pairs_dsp_miscore[diff < 0]$pair_id] -->
<!-- test_before <- intact_human[pair_id %in% comp_pairs_dsp_miscore[diff < 0]$pair_id & !(pmid %in% eval_dsp_pmids$pmid)] -->

<!-- test_after_mitab <- test_after[,`:=`(pmid = NULL, p1 = NULL, p2 = NULL, pair_id = NULL)] -->
<!-- fwrite( -->
<!--   test_after_mitab, -->
<!--   "./processed_data/test_after_mitab.txt", -->
<!--   col.names = T, -->
<!--   row.names = F, -->
<!--   quote = F, -->
<!--   sep = "\t" -->
<!-- ) -->

<!-- test_before_mitab <- test_before[,`:=`(pmid = NULL, p1 = NULL, p2 = NULL, pair_id = NULL)] -->
<!-- fwrite( -->
<!--   test_before_mitab, -->
<!--   "./processed_data/test_before_mitab.txt", -->
<!--   col.names = T, -->
<!--   row.names = F, -->
<!--   quote = F, -->
<!--   sep = "\t" -->
<!-- ) -->

<!-- test_before_mitab_miscore <- fread( -->
<!--   "./processed_data/test_before_clustered.txt", -->
<!--   header = F, -->
<!--   check.names = T, -->
<!--   stringsAsFactors = F, -->
<!--   colClasses = "character" -->
<!-- ) -->
<!-- colnames(test_before_mitab_miscore) <- colnames(intact_pairs_dsp_no_dsppmids_mitab)[1:15] -->

<!-- test_after_mitab_miscore <- fread( -->
<!--   "./processed_data/test_after_clustered.txt", -->
<!--   header = F, -->
<!--   check.names = T, -->
<!--   stringsAsFactors = F, -->
<!--   colClasses = "character" -->
<!-- ) -->
<!-- colnames(test_after_mitab_miscore) <- colnames(intact_pairs_dsp_no_dsppmids_mitab)[1:15] -->

<!-- test_pairs_before <- unique(test_before_mitab_miscore[,.( -->
<!--   # p1 = gsub("-.*","",gsub("uniprotkb:","",X.ID.s..interactor.A)), -->
<!--   # p2 = gsub("-.*","",gsub("uniprotkb:","",ID.s..interactor.B)), -->
<!--   pair_id = apply(data.table(gsub("uniprotkb:","",X.ID.s..interactor.A), -->
<!--                              gsub("uniprotkb:","",ID.s..interactor.B), -->
<!--                              stringsAsFactors = F), -->
<!--                   1, -->
<!--                   function(a) { z = sort(a) -->
<!--                   paste0(z[1],"_",z[2]) }), -->
<!--   miscore_before = as.numeric(gsub(".*miscore:","",Confidence.value.s.)))]) -->

<!-- test_pairs_after <- unique(test_after_mitab_miscore[,.( -->
<!--   # p1 = gsub("-.*","",gsub("uniprotkb:","",X.ID.s..interactor.A)), -->
<!--   # p2 = gsub("-.*","",gsub("uniprotkb:","",ID.s..interactor.B)), -->
<!--   pair_id = apply(data.table(gsub("uniprotkb:","",X.ID.s..interactor.A), -->
<!--                              gsub("uniprotkb:","",ID.s..interactor.B), -->
<!--                              stringsAsFactors = F), -->
<!--                   1, -->
<!--                   function(a) { z = sort(a) -->
<!--                   paste0(z[1],"_",z[2]) }), -->
<!--   miscore_after = as.numeric(gsub(".*miscore:","",Confidence.value.s.)))]) -->

<!-- comp_pairs_test_miscore <- unique(merge( -->
<!--   test_pairs_before, -->
<!--   test_pairs_after, -->
<!--   by = "pair_id", -->
<!--   all = T -->
<!--   )) -->

<!-- comp_pairs_test_miscore[is.na(miscore_before)]$miscore_before <- 0 -->
<!-- comp_pairs_test_miscore[,diff:=(miscore_after-miscore_before)] -->
<!-- ``` -->

<!-- Problem is that I need to clean up isoforms! -->

